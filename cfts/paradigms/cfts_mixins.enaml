import logging
log = logging.getLogger(__name__)

from functools import partial
import textwrap

import numpy as np
import pandas as pd

from atom.api import Enum, Float, Property, Str

from enaml.application import deferred_call
from enaml.core.api import Conditional, d_
from enaml.workbench.core.api import Command
from enaml.layout.api import vbox
from enaml.stdlib.fields import FloatField
from enaml.widgets.api import Container, DockItem, HGroup, Label, ObjectCombo
from enaml.workbench.api import Extension

from psiaudio.calibration import InterpCalibration, PointCalibration
from psiaudio.util import octave_space

from psi.context.api import (BaseSelector, BoolParameter, ContextGroup,
                             EnumParameter, FriendlyCartesianProduct,
                             Parameter)
from psi.controller.api import (get_hw_ai_choices, get_hw_ao_choices,
                                ContinuousInput, Detrend, Downsample,
                                EpochOutput, ExperimentAction, ExtractEpochs,
                                IIRFilter, Input, QueuedEpochOutput,
                                QueuedEpochOutputManifest, RejectEpochs)
from psi.controller.calibration.api import (chirp_sens, ChirpCalibrate,
                                            ToneCalibrate, tone_sens)
from psi.core.enaml.api import DataFrameTable, ExperimentManifest, PSIManifest
from psi.data.plots import (ChannelPlot, TimeContainer, ViewBox)
from psi.data.sinks.api import DisplayValue, TextStore, ZarrStore
from psi.token.api import BandlimitedNoise, Cos2Envelope, Gate, SquareWave



################################################################################
# Simple frequency and level selectors
################################################################################
CONTEXT_ITEM_DETAIL = {
    # ABR
    'target_tone_frequency': {
        'user_friendly_name': 'frequencies',
        'step_unit': 'octave',
        'unit': 'kHz',
        'order_user_managed': False,
        'transform_fn': lambda x: (x * 1e3).round(0),
        'inverse_transform_fn': lambda x: x * 1e-3,
        'round_values': True,
        'range_fn': octave_space,
    },
    'target_tone_level': {
        'user_friendly_name': 'levels',
        'step_unit': 'dB',
        'unit': 'dB SPL',
        'order_user_managed': True,
    },

    # DPOAE
    'f2_frequency': {
        'user_friendly_name': 'F2 frequencies',
        'step_unit': 'octave',
        'unit': 'kHz',
        'order_user_managed': False,
        'transform_fn': lambda x: (x * 1e3).round(0),
        'inverse_transform_fn': lambda x: x * 1e-3,
        'round_values': True,
        'range_fn': octave_space,
    },
    'f2_level': {
        'user_friendly_name': 'levels',
        'step_unit': 'dB',
        'unit': 'dB SPL',
        'order_user_managed': True,
    },
}


class CFTSSelector(FriendlyCartesianProduct):

    context_detail = CONTEXT_ITEM_DETAIL
    name = 'default'


enamldef TemperatureMixinManifest(ExperimentManifest): manifest:

    id = 'temperature_mixin'
    name = 'temperature'
    title = 'Temperature monitor'

    Extension:
        id = 'temperature_data'
        point = 'psi.data.sinks'

        ZarrStore:
            name = 'temperature_store'
            continuous_inputs = ['temperature']

        DisplayValue:
            name = 'temperature_display'
            label = 'Temperature'
            source_name = 'temperature_decimated'

    Extension:
        id = 'temperature_io'
        point = 'psi.controller.io'

        IIRFilter:
            source_name = 'temperature'
            f_lowpass = 0.5
            btype = 'lowpass'
            ftype = 'butter'
            N = 1

            Downsample:
                name = 'temperature_decimated'
                q = 500


################################################################################
# Hardware mixins
################################################################################
enamldef SpeakerOutput(QueuedEpochOutput):

    name = 'target'
    label = 'Target'
    configurable = False
    target_name = C.target_output_channel


enamldef SpeakerOutputManifest(QueuedEpochOutputManifest): manifest:

    Extension:
        id = manifest.id + '.context'
        point = 'psi.context.items'

        ContextGroup:
            name = 'hardware_settings'
            label = 'Hardware'

            EnumParameter:
                name = f'{contribution.name}_output_channel'
                label = f'{contribution.label} output channel'
                compact_label = 'ao'
                choices = get_hw_ao_choices(workbench)
                selected = next(iter(get_hw_ao_choices(workbench)))
                scope = 'experiment'


enamldef PTMicrophoneInput(ContinuousInput):
    name = 'microphone'
    source_name << C.pt_channel
    source ::
        channel.gain = C.pt_input_gain


enamldef PTMicrophoneInputManifest(PSIManifest): manifest:

    Extension:
        id = manifest.id + '.context'
        point = 'psi.context.items'

        EnumParameter:
            name = 'pt_channel'
            label = 'Probe tube mic. channel'
            choices = get_hw_ai_choices(workbench)
            selected = next(iter(get_hw_ai_choices(workbench)))
            scope = 'experiment'
            group_name = 'hardware_settings'

        Parameter:
            name = 'pt_input_gain'
            label = 'Probe tube input gain (dB)'
            dtype = 'float64'
            default = 40
            scope = 'experiment'
            group_name = 'hardware_settings'


enamldef EEGInput(ContinuousInput):
    source_name << C.eeg_channel
    name = 'eeg'

    IIRFilter:
        name = 'eeg_filtered'
        N = 2
        btype = 'bandpass'
        ftype = 'butter'
        passthrough = not C.digital_filter
        f_highpass = C.digital_highpass
        f_lowpass = C.digital_lowpass


enamldef EEGInputManifest(PSIManifest): manifest:

    Extension:
        id = manifest.id + '.context'
        point = 'psi.context.items'

        EnumParameter:
            name = 'eeg_channel'
            label = 'EEG channel'
            compact_label = 'ai_eeg'
            choices = get_hw_ai_choices(workbench)
            selected = next(iter(get_hw_ai_choices(workbench)))
            scope = 'experiment'
            group_name = 'hardware_settings'

        Parameter:
            name = 'amplifier_highpass'
            label = 'Amplifier highpass filter cutoff'
            default = 10
            scope = 'experiment'
            group_name = 'hardware_settings'

        Parameter:
            name = 'amplifier_lowpass'
            label = 'Amplifier lowpass filter cutoff'
            default = 10e3
            scope = 'experiment'
            group_name = 'hardware_settings'

        Parameter:
            name = 'amplifier_gain'
            label = 'Amplifier gain'
            default = 100e3
            scope = 'experiment'
            group_name = 'hardware_settings'

        ContextGroup:
            name = 'digital_filter'
            label = 'Digital filter settings'

            BoolParameter:
                name = 'digital_filter'
                label = 'Digital filter?'
                scope = 'experiment'
                default = True

            Parameter:
                name = 'digital_highpass'
                label = 'Digital highpass filter cutoff'
                default = 300
                scope = 'experiment'

            Parameter:
                name = 'digital_lowpass'
                label = 'Digital lowpass filter cutoff'
                default = 3000
                scope = 'experiment'


################################################################################
# ABR and DPOAE calibration mixins
################################################################################
enamldef InEarCalibrationMixinManifest(ExperimentManifest): manifest:

    attr experiment
    attr outputs
    id = f'{experiment}_inear_calibration_mixin'
    name = f'{experiment}_inear_calibration'
    title = 'In-ear calibration'

    Extension:
        id = manifest.id + '.context'
        point = 'psi.context.items'

        ContextGroup:
            name = 'inear_calibration'
            label = 'In-ear calibration settings'

            Parameter:
                name = 'calibration_gain'
                label = 'Gain (dB)'
                dtype = 'float'
                default = -30

    Extension:
        id = manifest.id + '.calibration'
        point = 'psi.controller.calibration.channels'

        ToneCalibrate:
            name = f'{experiment}_tone_calibration'
            label = 'Tone calibration'
            input_name = 'microphone'
            outputs << manifest.outputs
            gain << C.calibration_gain
            max_thd = None
            min_snr = 5
            duration = 0.1
            trim = 0.01
            iti = 0


enamldef ABRInEarCalibrationMixinManifest(InEarCalibrationMixinManifest): manifest:

    experiment = 'abr'
    outputs = {'target': ['target_tone_frequency']}


enamldef DPOAEInEarCalibrationMixinManifest(InEarCalibrationMixinManifest): manifest:

    experiment = 'dpoae'
    outputs = {
        'primary': ['primary_tone_frequency'],
        'secondary': ['secondary_tone_frequency'],
    }


enamldef EFRInEarCalibrationManifest(InEarCalibrationMixinManifest): manifest:

    experiment = 'efr'
    outputs = {
        'primary': ['carrier_tone_frequency'],
    }
