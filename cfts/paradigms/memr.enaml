import logging
log = logging.getLogger(__name__)

from atom.api import Float, Int
from enaml.core.api import d_
from enaml.workbench.api import Extension
from enaml.workbench.core.api import Command

import numpy as np

from psiaudio.pipeline import concat, coroutine, PipelineData
from psiaudio.queue import BlockedFIFOSignalQueue
from psiaudio import util

from psi.context.api import ContextGroup, Expression, Parameter
from psi.controller.api import (
    Blocked, ControllerManifest, Coroutine, EpochInput, ExperimentAction,
    ExtractEpochs, Synchronized
)
from psi.core.enaml.api import ExperimentManifest
from psi.token.primitives import (
    BandlimitedClick, BandlimitedFIRNoise, Chirp, Cos2Envelope, Repeat
)
from psi.data.api import FFTContainer, TimeContainer, ViewBox
from psi.data.sinks.api import BinaryStore, EpochCounter, TextStore

from psi.data.api import (
    EpochTimeContainer, GroupedEpochAveragePlot, GroupedEpochFFTPlot
)

from .cfts_mixins import CalMicrophoneInput, CFTSSelector, EEGInput, PTMicrophoneInput
from psi.paradigms.core.io_mixins import QueuedEpochChannelOutput

EXPERIMENT = __name__.rsplit('.', 1)[-1]


def configure_interleaved_memr(event):
    context = event.workbench.get_plugin('psi.context')
    controller = event.workbench.get_plugin('psi.controller')
    data = event.workbench.get_plugin('psi.data')

    probe = controller.get_output('probe')
    elicitor = controller.get_output('elicitor')
    probe.queue = BlockedFIFOSignalQueue()
    elicitor.queue = BlockedFIFOSignalQueue()

    for polarity in (1, -1):
        for setting in context.iter_settings('default', 1):
            averages = max(1, int(round(setting['trial_n'] / 2)))
            trial_duration = setting['trial_period']
            setting['elicitor_bandlimited_noise_polarity'] = polarity
            probe.add_setting(setting, averages=averages, total_duration=trial_duration)
            elicitor.add_setting(setting, averages=averages, total_duration=trial_duration)

    # Then figure out the maximum scaling factor required for that level.
    # Multiply to convert from RMS to peak to peak and add 1% headroom.
    #max_sf = {}
    #for frequency, level in max_level.items():
    #    sf = output.calibration.get_sf(frequency, level)
    #    max_sf[frequency] = sf
    #max_sf = max(max_sf.values()) * np.sqrt(2) * 1.01 * 2
    #log.info(max_sf)
    #output.channel.expected_range = (-max_sf, max_sf)


@coroutine
def stack_repeats(repeat_period, target):
    while True:
        new_data = []
        for data in (yield):
            s_repeat = int(round(repeat_period * data.fs))
            data_repeat = np.asarray(data).reshape((-1, data.n_channels, s_repeat))
            for i, d in enumerate(data_repeat):
                new_d = PipelineData(d, fs=data.fs, s0=0, channel=data.channel,
                                     metadata=data.metadata.copy())
                new_d.add_metadata('repeat', i)
                new_data.append(new_d)

        new_data = concat(new_data, axis='epoch')
        target(new_data)


class StackRepeats(EpochInput):

    duration = d_(Float()).tag(metadata=True)

    def configure_callback(self):
        cb = super().configure_callback()
        return stack_repeats(self.duration, cb).send


@coroutine
def extract_stim(lb, ub, target):
    ilb, iub = None, None
    while True:
        data = (yield)
        if iub is None:
            ilb = int(round(lb * data.fs))
            iub = int(round(ub * data.fs))
        target(data[..., ilb:iub])


class ExtractStim(EpochInput):

    lb = d_(Float()).tag(metadata=True)
    ub = d_(Float()).tag(metadata=True)

    def configure_callback(self):
        cb = super().configure_callback()
        return extract_stim(self.lb, self.ub, cb).send


class GroupedMEMRPlot(GroupedEpochFFTPlot):

    final_probe = d_(Int())

    def _y(self, epoch):
        b = [e for e in epoch if e.metadata['repeat'] == 0]
        r = [e for e in epoch if e.metadata['repeat'] == self.final_probe]
        b = np.array(concat(b, axis='epoch'))[:, self.channel]
        r = np.array(concat(r, axis='epoch'))[:, self.channel]
        result = util.db(util.psd(r, self.source.fs)) - util.db(util.psd(b, self.source.fs))
        return result.mean(axis=0)


enamldef BaseMEMRManifest(ControllerManifest): manifest:

    attr configure_experiment_cb
    attr analyze_memr_cb
    attr probe

    Extension:
        id = EXPERIMENT + '.base_context'
        point = 'psi.context.items'

        ContextGroup:
            name = 'hardware_settings'
            label = 'Hardware'

    Extension:
        id = EXPERIMENT + '.io'
        point = 'psi.controller.io'

        CalMicrophoneInput:
            pass

        PTMicrophoneInput:
            ExtractEpochs: extract:
                name = 'memr'
                StackRepeats:
                    name = 'memr_repeat'
                    duration = C.repeat_period
                    ExtractStim:
                        # Add a bit of padding to capture the tail end of the
                        # probe due to acoustic delays
                        name = 'probe'
                        lb = C.probe_delay
                        ub = C.probe_delay + C.probe_duration + 1e-3

                    ExtractStim:
                        # Add a bit of padding to capture the tail end of the
                        # probe due to acoustic delays
                        name = 'elicitor'
                        lb = C.elicitor_envelope_start_time
                        ub = C.elicitor_envelope_start_time + C.elicitor_duration

        Synchronized:
            name = 'memr_stim'
            QueuedEpochChannelOutput:
                name = 'probe'
                label = 'Probe'
                auto_decrement = True
                token = workbench.get_plugin('psi.token').get_token(probe)
                queue ::
                    self.connect(extract.added_queue.append, 'added')
                    self.connect(extract.removed_queue.append, 'removed')
            QueuedEpochChannelOutput:
                name = 'elicitor'
                label = 'Elicitor'
                token = workbench.get_plugin('psi.token').get_token('noise')
                auto_decrement = True

    Extension:
        id = EXPERIMENT + '.selectors'
        point = 'psi.context.selectors'

        CFTSSelector:
            label = 'MEMR stimuli'
            can_manage = ['elicitor_bandlimited_noise_level']
            user_managed = False

    Extension:
        id = EXPERIMENT + '.commands'
        point = 'enaml.workbench.core.commands'

        Command:
            id = 'psi.controller.configure_experiment'
            handler = configure_experiment_cb

    Extension:
        id = EXPERIMENT + '.actions'
        point = 'psi.controller.actions'

        ExperimentAction:
            event = 'experiment_prepare'
            command = 'psi.controller.configure_experiment'
            weight = 11

        ExperimentAction:
            event = 'experiment_initialize'
            command = 'psi.context.initialize'
            kwargs = {'selector': 'default', 'cycles': 1}

        ExperimentAction:
            event = 'engines_configured'
            command = 'memr_stim.start'
            kwargs = {'delay': 0.5}

        ExperimentAction:
            event = 'memr_queue_end'
            command = 'psi.controller.stop'

    Extension:
        id = EXPERIMENT + '.data'
        point = 'psi.data.sinks'

        EpochCounter: counter:
            name = 'memr_counter'
            label = 'MEMRs acquired'
            source_name = 'memr'
            output_name = 'probe'

        BinaryStore:
            name = 'memr_binary_store'
            continuous_inputs = ['microphone', 'cal_microphone']

        TextStore:
            name = 'memr_store'
            epoch_inputs = ['memr']

    Extension:
        id = EXPERIMENT + '.plots'
        point = 'psi.data.plots'

        EpochTimeContainer: probe_time_container:
            name = 'probe_time_container'
            label = 'Probe waveform'

            max_buttons = 4
            fmt_button_cb << \
                C.get_selector().get_formatter(probe_plot.tab_grouping)

            ViewBox: probe_time_vb:
                name = 'probe_time_vb'
                y_mode = 'mouse'
                save_limits = True

                GroupedEpochAveragePlot: probe_plot:
                    source_name = 'probe'
                    plot_grouping = ['repeat']
                    plot_keys = [(k,) for k in range(C.elicitor_n + 1)]
                    autogenerate_keys = 'tab'
                    tab_grouping << C.get_names()
                    tab_keys >> probe_time_container.buttons
                    selected_tab := probe_time_container.current_button
                    auto_select := probe_time_container.auto_select
                    fmt_plot_label_cb = lambda x, s: f'Probe {x[0]}'

        FFTContainer: probe_fft_container:
            name = 'probe_fft_container'
            label = 'Probe and Elicitor PSD'
            freq_lb = 0.5e3
            freq_ub = 50e3

            max_buttons = 4
            fmt_button_cb << \
                C.get_selector().get_formatter(probe_fft_plot.tab_grouping)

            ViewBox:
                name = 'probe_fft_vb'
                y_mode = 'mouse'
                save_limits = True

                GroupedEpochFFTPlot: probe_fft_plot:
                    source_name = 'probe'
                    plot_grouping = ['repeat']
                    autogenerate_keys = 'tab'
                    plot_keys = [(k,) for k in range(C.elicitor_n + 1)]
                    tab_grouping << C.get_names()
                    tab_keys >> probe_fft_container.buttons
                    selected_tab := probe_fft_container.current_button
                    auto_select := probe_fft_container.auto_select
                    apply_calibration = True
                    fmt_plot_label_cb = lambda x, s: f'Probe {x[0]}'

                GroupedEpochFFTPlot: elicitor_fft_plot:
                    source_name = 'elicitor'
                    plot_grouping = ['repeat']
                    autogenerate_keys = 'tab'
                    plot_keys = [(k,) for k in range(C.elicitor_n + 1)]
                    tab_grouping << C.get_names()
                    tab_keys >> probe_fft_container.buttons
                    selected_tab := probe_fft_container.current_button
                    auto_select := probe_fft_container.auto_select
                    apply_calibration = True
                    fmt_plot_label_cb = lambda x, s: f'Elicitor {x[0]}'

        FFTContainer:
            name = 'memr_fft_container'
            label = 'MEMR'
            freq_lb = 5.6e3
            freq_ub = 45e3

            ViewBox:
                name = 'memr_fft_vb'
                y_mode = 'mouse'
                save_limits = True

                GroupedMEMRPlot:
                    final_probe = C.elicitor_n
                    name = 'memr_fft_plot'
                    source_name = 'probe'
                    plot_grouping << C.get_names()
                    pen_width = 2


enamldef InterleavedElicitorMixin(ExperimentManifest):

    id = 'interleaved_elicitor_stim'

    Extension:
        id = EXPERIMENT + '.interleaved_elicitor.items'
        point = 'psi.context.items'

        ContextGroup:
            name = 'memr'
            label = 'MEMR'

            Parameter:
                name = 'elicitor_n'
                label = 'Elicitor pulses'
                default = 4

            Parameter:
                name = 'repeat_period'
                label = 'Stim repeat period'
                default = 186e-3

            Parameter:
                name = 'trial_period'
                label = 'Trial repeat period'
                default = 1.580

            Parameter:
                name = 'trial_n'
                label = 'Number of trials'
                default = 2

            Parameter:
                name = 'elicitor_duration'
                label = 'Elicitor duration'
                default = 116e-3

            Parameter:
                name = 'analysis_window'
                label = 'Analysis window'
                default = 46.4e-3

        Expression:
            parameter = 'elicitor_noise_n'
            expression = 'elicitor_n'

        Expression:
            parameter = 'elicitor_noise_rate'
            expression = '1 / repeat_period'

        Expression:
            parameter = 'elicitor_noise_skip_n'
            expression = '0'

        Expression:
            parameter = 'elicitor_envelope_duration'
            expression = 'elicitor_duration'

        Expression:
            parameter = 'elicitor_envelope_rise_time'
            expression = '5e-3'

        Expression:
            parameter = 'elicitor_envelope_start_time'
            expression = 'repeat_period - elicitor_duration'


enamldef InterleavedClickProbeMixin(ExperimentManifest):

    id = 'interleaved_click_probe_stim'

    Extension:
        id = EXPERIMENT + '.interleaved_click_probe.items'
        point = 'psi.context.items'

        Expression:
            parameter = f'probe_click_n'
            expression = 'elicitor_n + 1'

        Expression:
            parameter = 'probe_click_skip_n'
            expression = '0'

        Expression:
            parameter = 'probe_click_rate'
            expression = '1 / repeat_period'

        Expression:
            parameter = 'probe_click_delay'
            expression = '11.2e-3 - probe_bandlimited_click_window / 2'

        Expression:
            parameter = 'probe_delay'
            expression = 'probe_click_delay'

        Expression:
            parameter = 'probe_duration'
            expression = 'probe_bandlimited_click_window'


enamldef InterleavedChirpProbeMixin(ExperimentManifest):

    id = 'interleaved_chirp_probe_stim'

    Extension:
        id = EXPERIMENT + '.interleaved_chirp_probe.items'
        point = 'psi.context.items'

        Expression:
            parameter = f'probe_chirp_n'
            expression = 'elicitor_n + 1'

        Expression:
            parameter = 'probe_chirp_skip_n'
            expression = '0'

        Expression:
            parameter = 'probe_chirp_rate'
            expression = '1 / repeat_period'

        Expression:
            parameter = 'probe_chirp_delay'
            expression = 'elicitor_envelope_start_time - analysis_window'

        Expression:
            parameter = 'probe_delay'
            expression = 'probe_chirp_delay'

        Expression:
            parameter = 'probe_duration'
            expression = 'probe_chirp_duration'


enamldef InterleavedMEMRManifest(BaseMEMRManifest):

    # Implements the classic wideband acoustic reflex as described by Keefe.
    analyze_memr_cb = analyze_interleaved_memr
    configure_experiment_cb = configure_interleaved_memr
    attr probe

    Extension:
        id = EXPERIMENT + '.interleaved_elicitor.tokens'
        point = 'psi.token.tokens'

        Repeat: elicitor:
            name = 'noise'
            hide = ['delay']
            Cos2Envelope:
                BandlimitedFIRNoise:
                    pass

        Repeat: probe:
            name = 'click'
            hide = ['skip_n']
            BandlimitedClick:
                hide = ['polarity']

        Repeat: chirp:
            name = 'chirp'
            hide = ['skip_n']
            Chirp:
                pass
