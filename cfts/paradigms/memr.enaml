import logging
log = logging.getLogger(__name__)

from functools import partial

from atom.api import Dict, Float, Int
from enaml.core.api import Conditional, d_
from enaml.stdlib.message_box import question
from enaml.workbench.api import Extension
from enaml.workbench.core.api import Command

import numpy as np

from psiaudio.pipeline import concat, coroutine, PipelineData
from psiaudio.queue import BlockedFIFOSignalQueue, GroupedFIFOSignalQueue
from psiaudio import util

from psi.context.api import (BoolParameter, ContextGroup, ContextRow,
                             EnumParameter, Expression, Parameter)
from psi.controller.api import (
    Blocked, ChannelOutOfRange, ContinuousInput, ControllerManifest, Coroutine,
    EpochInput, ExperimentAction, ExtractEpochs, Synchronized,
    QueuedEpochOutput
)
from psi.core.enaml.api import ExperimentManifest
from psi.token.primitives import (
    BandlimitedClick, BandlimitedFIRNoise, Chirp, Cos2Envelope, Repeat
)
from psi.data.api import (
    ChannelPlot, FFTChannelPlot, FFTContainer, TimeContainer, ViewBox
)
from psi.data.sinks.api import BinaryStore, EpochCounter, TextStore

from psi.data.api import (
    EpochTimeContainer, GroupedEpochAveragePlot, GroupedEpochFFTPlot
)

from .cfts_mixins import CFTSSelector, EEGInput

EXPERIMENT = __name__.rsplit('.', 1)[-1]


################################################################################
# Microphone mixins
################################################################################
enamldef MEMRSignalViewManifest(ExperimentManifest): manifest:

    id = 'memr_microphone_signal_view'
    title = 'Microphone (time)'

    Extension:
        id = 'plots'
        point = 'psi.data.plots'

        TimeContainer: time_container:
            name << manifest.name + '_container'
            label << manifest.title
            span = 4
            delay = 0.125

            ViewBox: vb:
                name << manifest.name + '_vb'
                y_min = -0.2
                y_max = 0.2
                y_mode = 'mouse'
                save_limits = True
                y_label = 'Signal (V)'

                ChannelPlot:
                    name << manifest.name + '_elicitor_plot'
                    pen_color = 'DarkCyan'
                    source_name = 'elicitor_microphone'

                ChannelPlot:
                    name << manifest.name + '_probe_plot'
                    pen_color = 'DarkMagenta'
                    source_name = 'probe_microphone'


enamldef MEMRSignalFFTViewManifest(ExperimentManifest): manifest:

    id = 'memr_microphone_signal_fft_view'
    title = 'Microphone (PSD)'

    Extension:
        id = manifest.id  + '.plots'
        point = 'psi.data.plots'

        FFTContainer: fft_container:
            name << manifest.name + '_container'
            label << manifest.title
            freq_lb = 5
            freq_ub = 50000

            ViewBox: fft_vb:
                name << manifest.name + '_vb'
                y_min = -10
                y_max = 100
                y_mode = 'mouse'
                save_limits = True
                y_label = 'Signal (dB)'

                FFTChannelPlot:
                    name << manifest.name + '_elicitor_plot'
                    source_name = 'elicitor_microphone'
                    pen_color = 'red'
                    time_span = 0.25
                    apply_calibration = True

                FFTChannelPlot:
                    name << manifest.name + '_probe_plot'
                    source_name = 'probe_microphone'
                    pen_color = 'blue'
                    time_span = 0.25
                    apply_calibration = True


def configure_memr(event, duration_attr, iti_attr=None):
    context = event.workbench.get_plugin('psi.context')
    controller = event.workbench.get_plugin('psi.controller')

    probe = controller.get_output('probe')
    elicitor = controller.get_output('elicitor')
    probe.queue = BlockedFIFOSignalQueue()
    elicitor.queue = BlockedFIFOSignalQueue()

    elicitor_sf = 0
    probe_sf = 0

    bad_settings = {}
    for setting in context.iter_settings('default', 1):
        for polarity in (1, -1):
            averages = max(1, int(round(setting['trial_n'] / 2)))
            if iti_attr is None:
                iti = 0
            else:
                iti = setting[iti_attr]
            duration = setting[duration_attr] + iti
            setting['elicitor_bandlimited_noise_polarity'] = polarity
            try:
                elicitor_uid, elicitor_factory = elicitor.add_setting(
                    setting, averages=averages, total_duration=duration)
            except ChannelOutOfRange as e:
                level = setting['elicitor_bandlimited_noise_level']
                bad_settings[level] = e.db
                # Important to continue! We do not want to add the probe to the
                # queue if the elicitor was not queued.
                continue

            # This should come *after* so we don't add a probe with a silent
            # elicitor to the queue.
            try:
                probe_uid, probe_factory = probe.add_setting(
                    setting, averages=averages, total_duration=duration)
            except ChannelOutOfRange as e:
                raise ValueError(f'Probe level is {e.db:.1f} dB too high.')

            elicitor_sf = max(elicitor_sf, elicitor_factory.max_amplitude() * 1.1)
            probe_sf = max(probe_sf, probe_factory.max_amplitude() * 1.1)

    if len(bad_settings):
        levels = list(sorted(bad_settings.keys()))
        max_level = levels[0] - bad_settings[levels[0]]
        to_remove_text = ', '.join([f'{l}' for l in sorted(levels)])
        mesg = f'Maximum elicitor level is {max_level:.1f} dB. Remove {to_remove_text} and proceed?'
        result = question(None, 'Settings', mesg)
        if result.text == 'Yes':
            pass
        else:
            import sys
            sys.exit()

    if probe.channel == elicitor.channel:
        sf = max(elicitor_sf, probe_sf)
        probe.channel.expected_range = (-sf, sf)
    else:
        probe.channel.expected_range = (-probe_sf, probe_sf)
        elicitor.channel.expected_range = (-elicitor_sf, elicitor_sf)


@coroutine
def stack_repeats(repeat_period, target):
    while True:
        new_data = []
        for data in (yield):
            s_repeat = int(round(repeat_period * data.fs))
            data_repeat = np.asarray(data).reshape((-1, data.n_channels, s_repeat))
            for i, d in enumerate(data_repeat):
                new_d = PipelineData(d, fs=data.fs, s0=0, channel=data.channel,
                                     metadata=data.metadata.copy())
                new_d.add_metadata('repeat', i)
                new_data.append(new_d)

        new_data = concat(new_data, axis='epoch')
        target(new_data)


class StackRepeats(EpochInput):

    duration = d_(Float()).tag(metadata=True)

    def configure_callback(self):
        cb = super().configure_callback()
        return stack_repeats(self.duration, cb).send


@coroutine
def extract_repeats(repeats, target):
    while True:
        data = (yield)
        subsets = []
        for name, (lb, ub) in repeats.items():
            d = data[lb:ub]
            d.add_metadata('range', name)
            subsets.append(d)
        result = concat(subsets, axis='epoch')
        target(result)


class ExtractRepeats(EpochInput):

    ranges = d_(Dict()).tag(metadata=True)

    def configure_callback(self):
        cb = super().configure_callback()
        return extract_repeats(self.ranges, cb).send


@coroutine
def extract_stim(lb, ub, target):
    ilb, iub = None, None
    while True:
        data = (yield)
        if iub is None:
            ilb = int(round(lb * data.fs))
            iub = int(round(ub * data.fs))
        target(data[..., ilb:iub])


class ExtractStim(EpochInput):

    lb = d_(Float()).tag(metadata=True)
    ub = d_(Float()).tag(metadata=True)

    def configure_callback(self):
        cb = super().configure_callback()
        return extract_stim(self.lb, self.ub, cb).send


class GroupedInterleavedMEMRPlot(GroupedEpochFFTPlot):

    final_probe = d_(Int())

    def _y(self, epoch):
        b = [e for e in epoch if e.metadata['repeat'] == 0]
        r = [e for e in epoch if e.metadata['repeat'] == self.final_probe]
        b = np.array(concat(b, axis='epoch'))[:, self.channel]
        r = np.array(concat(r, axis='epoch'))[:, self.channel]
        result = util.db(util.psd(r, self.source.fs)) - util.db(util.psd(b, self.source.fs))
        return result.mean(axis=0)


class GroupedSimultaneousMEMRPlot(GroupedEpochFFTPlot):

    def _y(self, epoch):
        norm = [e for e in epoch if e.metadata['range'] == 'norm']
        elicitor = [e for e in epoch if e.metadata['range'] == 'elicitor']
        norm = np.array(concat(norm, axis='epoch'))[:, self.channel]
        elicitor = np.array(concat(elicitor, axis='epoch'))[:, self.channel]

        norm_psd = util.db(util.psd(norm.mean(axis=0), self.source.fs))
        elicitor_psd = util.db(util.psd(elicitor.mean(axis=0), self.source.fs))
        return elicitor_psd - norm_psd


enamldef BaseMEMRManifest(ControllerManifest): manifest:

    attr configure_experiment_cb
    attr analyze_memr_cb
    attr probe

    attr plot_keys

    Extension:
        id = EXPERIMENT + '.base_context'
        point = 'psi.context.items'

        ContextGroup:
            name = 'hardware_settings'
            label = 'Hardware'

    Extension:
        id = EXPERIMENT + '.io'
        point = 'psi.controller.io'

        ExtractEpochs: extract_probe:
            source_name = 'probe_microphone'
            name = 'memr_probe'

        ExtractEpochs: extract_elicitor:
            source_name = 'elicitor_microphone'
            name = 'memr_elicitor'

        Synchronized:
            name = 'memr_stim'
            QueuedEpochOutput:
                name = 'probe'
                label = 'Probe'
                target_name = 'probe_primary'
                auto_decrement = True
                token = workbench.get_plugin('psi.token').get_token(probe)
                queue ::
                    extract_probe.subscribe_to_queue(self.queue)
            QueuedEpochOutput:
                name = 'elicitor'
                label = 'Elicitor'
                target_name = 'elicitor_secondary'
                auto_decrement = True
                token = workbench.get_plugin('psi.token').get_token('noise')
                queue ::
                    extract_elicitor.subscribe_to_queue(self.queue)

    Extension:
        id = EXPERIMENT + '.selectors'
        point = 'psi.context.selectors'

        CFTSSelector:
            label = 'MEMR stimuli'
            can_manage = ['elicitor_bandlimited_noise_level']
            user_managed = False

    Extension:
        id = EXPERIMENT + '.context'
        point = 'psi.context.items'

        ContextGroup:
            name = 'memr'
            label = 'MEMR'

            ContextRow:
                name = 'elicitor'
                fmt = ['Elicitor', elicitor_fl, 'to', elicitor_fh, 
                       'Hz, equalize up to ±', elicitor_eq_max, 'db, apply',
                       elicitor_audiogram, 'audiogram']

                Parameter: elicitor_fl:
                    name = 'elicitor_fl'
                    default = 8e3
                    scope = 'trial'

                Parameter: elicitor_fh:
                    name = 'elicitor_fh'
                    default = 16e3
                    scope = 'trial'

                Parameter: elicitor_eq_max:
                    name = 'elicitor_max_equalize'
                    default = 20
                    scope = 'trial'

                EnumParameter: elicitor_audiogram:
                    name = 'elicitor_audiogram_weighting'
                    default = 'mouse'
                    choices = {'no': None, 'mouse': "'mouse'"}

            ContextRow:
                name = 'probe'
                fmt = ['Probe', probe_fl, 'to', probe_fh, 'Hz at', probe_level,
                       'dB SPL, equalize up to ±', probe_eq_max, 'db, apply',
                       probe_audiogram, 'audiogram']

                Parameter: probe_fl:
                    name = 'probe_fl'
                    default = 4e3
                    scope = 'trial'

                Parameter: probe_fh:
                    name = 'probe_fh'
                    default = 32e3
                    scope = 'trial'

                Parameter: probe_level:
                    name = 'probe_level'
                    default = 75
                    scope = 'trial'

                Parameter: probe_eq_max:
                    name = 'probe_max_equalize'
                    default = 20
                    scope = 'trial'

                EnumParameter: probe_audiogram:
                    name = 'probe_audiogram_weighting'
                    default = 'mouse'
                    choices = {'no': None, 'mouse': "'mouse'"}


    Extension:
        id = EXPERIMENT + '.commands'
        point = 'enaml.workbench.core.commands'

        Command:
            id = 'psi.controller.configure_experiment'
            handler = configure_experiment_cb

    Extension:
        id = EXPERIMENT + '.actions'
        point = 'psi.controller.actions'

        ExperimentAction:
            event = 'experiment_prepare'
            command = 'psi.controller.configure_experiment'
            weight = 11

        ExperimentAction:
            event = 'experiment_initialize'
            command = 'psi.context.initialize'
            kwargs = {'selector': 'default', 'cycles': 1}

        ExperimentAction:
            event = 'engines_configured'
            command = 'memr_stim.start'
            kwargs = {'delay': 0.5}

        ExperimentAction:
            event = 'memr_probe_queue_end'
            command = 'psi.controller.stop'

    Extension:
        id = EXPERIMENT + '.data'
        point = 'psi.data.sinks'

        EpochCounter: counter:
            name = 'memr_counter'
            label = 'MEMRs acquired'
            source_name = 'memr_probe'
            output_name = 'probe'

        BinaryStore:
            name = 'memr_binary_store'
            continuous_inputs = ['probe_microphone', 'elicitor_microphone']

        TextStore:
            name = 'memr_store'
            epoch_inputs = ['memr_probe']


################################################################################
# Interleaved MEMR
################################################################################
enamldef InterleavedElicitorMixin(ExperimentManifest):

    id = 'interleaved_elicitor_stim'

    Extension:
        id = EXPERIMENT + '.interleaved_elicitor.items'
        point = 'psi.context.items'

        Parameter:
            name = 'elicitor_n'
            label = 'Elicitor pulses'
            default = 4
            group_name = 'memr'

        Parameter:
            name = 'repeat_period'
            label = 'Stim repeat period'
            default = 186e-3
            group_name = 'memr'

        Parameter:
            name = 'trial_period'
            label = 'Trial repeat period'
            default = 1.580
            group_name = 'memr'

        Parameter:
            name = 'trial_n'
            label = 'Number of trials'
            default = 2
            group_name = 'memr'

        Parameter:
            name = 'elicitor_duration'
            label = 'Elicitor duration'
            default = 116e-3
            group_name = 'memr'

        Parameter:
            name = 'analysis_window'
            label = 'Analysis window'
            default = 46.4e-3
            group_name = 'memr'

        Expression:
            parameter = 'elicitor_noise_n'
            expression = 'elicitor_n'

        Expression:
            parameter = 'elicitor_noise_rate'
            expression = '1 / repeat_period'

        Expression:
            parameter = 'elicitor_noise_skip_n'
            expression = '0'

        Expression:
            parameter = 'elicitor_envelope_duration'
            expression = 'elicitor_duration'

        Expression:
            parameter = 'elicitor_envelope_rise_time'
            expression = '5e-3'

        Expression:
            parameter = 'elicitor_envelope_start_time'
            expression = 'repeat_period - elicitor_duration'

        Expression:
            parameter = 'elicitor_bandlimited_noise_fl'
            expression = 'elicitor_fl'

        Expression:
            parameter = 'elicitor_bandlimited_noise_fh'
            expression = 'elicitor_fh'

        Expression:
            parameter = 'elicitor_bandlimited_noise_equalize'
            expression = 'elicitor_max_equalize != 0'

        Expression:
            parameter = 'elicitor_bandlimited_noise_seed'
            expression = '1'

        Expression:
            parameter = 'elicitor_bandlimited_noise_max_correction'
            expression = 'elicitor_max_equalize'

        Expression:
            parameter = 'elicitor_bandlimited_noise_audiogram_weighting'
            expression = 'elicitor_audiogram_weighting'


enamldef InterleavedClickProbeMixin(ExperimentManifest):

    id = 'interleaved_click_probe_stim'

    Extension:
        id = EXPERIMENT + '.interleaved_click_probe.items'
        point = 'psi.context.items'

        Expression:
            parameter = f'probe_click_n'
            expression = 'elicitor_n + 1'

        Expression:
            parameter = 'probe_click_skip_n'
            expression = '0'

        Expression:
            parameter = 'probe_click_rate'
            expression = '1 / repeat_period'

        Expression:
            parameter = 'probe_click_delay'
            expression = '11.2e-3 - probe_bandlimited_click_window / 2'

        Expression:
            parameter = 'probe_delay'
            expression = 'probe_click_delay'

        Expression:
            parameter = 'probe_duration'
            expression = 'probe_bandlimited_click_window'

        Expression:
            parameter = 'probe_bandlimited_click_flb'
            expression = 'probe_fl'

        Expression:
            parameter = 'probe_bandlimited_click_fub'
            expression = 'probe_fh'

        Expression:
            parameter = 'probe_bandlimited_click_level'
            expression = 'probe_level'

        Expression:
            parameter = 'probe_bandlimited_click_window'
            expression = '5e-3'


enamldef InterleavedChirpProbeMixin(ExperimentManifest):

    id = 'interleaved_chirp_probe_stim'

    Extension:
        id = EXPERIMENT + '.interleaved_chirp_probe.items'
        point = 'psi.context.items'

        Expression:
            parameter = f'probe_chirp_n'
            expression = 'elicitor_n + 1'

        Expression:
            parameter = 'probe_chirp_skip_n'
            expression = '0'

        Expression:
            parameter = 'probe_chirp_rate'
            expression = '1 / repeat_period'

        Expression:
            parameter = 'probe_chirp_delay'
            expression = 'probe_delay'

        Expression:
            parameter = 'probe_chirp_start_frequency'
            expression = 'probe_fl'

        Expression:
            parameter = 'probe_chirp_end_frequency'
            expression = 'probe_fh'

        Expression:
            parameter = 'probe_chirp_level'
            expression = 'probe_level'

        Parameter:
            name = 'probe_delay'
            label = 'probe delay'
            default = 10e-3
            group_name = 'memr'

        ContextRow:
            fmt = ['Probe', probe_duration, 'sec with', probe_window, 'window']
            group_name = 'memr'

            Parameter: probe_duration:
                name = 'probe_duration'
                default = 2e-3

            EnumParameter: probe_window:
                name = 'probe_window'
                choices = {
                    'hann': '"hann"',
                    'boxcar': '"boxcar"',
                }

        Expression:
            parameter = 'probe_chirp_duration'
            expression = 'probe_duration'

        Expression:
            parameter = 'probe_chirp_window'
            expression = 'probe_window'

        Expression:
            parameter = 'probe_chirp_equalize'
            expression = 'probe_max_equalize != 0'

        Expression:
            parameter = 'probe_chirp_max_correction'
            expression = 'probe_max_equalize'

        Expression:
            parameter = 'probe_chirp_audiogram_weighting'
            expression = 'probe_audiogram_weighting'


enamldef InterleavedMEMRManifest(BaseMEMRManifest):

    # Implements the classic wideband acoustic reflex as described by Keefe.
    configure_experiment_cb = partial(configure_memr,
                                      duration_attr='trial_period', iti_attr=None)

    Extension:
        id = EXPERIMENT + '.interleaved_elicitor.tokens'
        point = 'psi.token.tokens'

        Repeat: elicitor:
            name = 'noise'
            hide = ['delay']
            Cos2Envelope:
                BandlimitedFIRNoise:
                    hide = ['polarity']

        Repeat: probe:
            name = 'click'
            hide = ['skip_n']
            BandlimitedClick:
                hide = ['polarity']

        Repeat: chirp:
            name = 'chirp'
            hide = ['skip_n']
            Chirp:
                pass

    Extension:
        id = EXPERIMENT + '.interleaved_memr.io'
        point = 'psi.controller.io'

        StackRepeats:
            source_name = 'memr_probe'
            name = 'memr_probe_repeat'
            duration = C.repeat_period

            ExtractStim:
                # Add a bit of padding to capture the tail end of the
                # probe due to acoustic delays
                name = 'probe'
                lb = C.probe_delay + 0.75e-3
                ub = C.probe_delay + C.probe_duration + 0.75e-3

        StackRepeats:
            source_name = 'memr_elicitor'
            name = 'memr_elicitor_repeat'
            duration = C.repeat_period

            ExtractStim:
                # Add a bit of padding to capture the tail end of the
                # probe due to acoustic delays
                name = 'elicitor'
                lb = C.elicitor_envelope_start_time
                ub = C.elicitor_envelope_start_time + C.elicitor_duration


    Extension:
        id = EXPERIMENT + '.plots'
        point = 'psi.data.plots'

        EpochTimeContainer: probe_time_container:
            name = 'probe_time_container'
            label = 'Probe waveform'

            max_buttons = 4
            fmt_button_cb << \
                C.get_selector().get_formatter(probe_plot.tab_grouping)

            ViewBox: probe_time_vb:
                name = 'probe_time_vb'
                y_mode = 'mouse'
                save_limits = True

                GroupedEpochAveragePlot: probe_plot:
                    source_name = 'probe'
                    plot_grouping = ['repeat']
                    plot_keys = [(k,) for k in range(C.elicitor_n + 1)]
                    autogenerate_keys = 'tab'
                    tab_grouping << C.get_names()
                    fmt_plot_label_cb = lambda x, s: f'Probe {x[0]}'

        FFTContainer: probe_fft_container:
            name = 'probe_fft_container'
            label = 'Probe and Elicitor PSD'
            freq_lb = 0.5e3
            freq_ub = 50e3

            max_buttons = 4
            fmt_button_cb << \
                C.get_selector().get_formatter(probe_fft_plot.tab_grouping)

            ViewBox:
                name = 'probe_fft_vb'
                y_mode = 'mouse'
                save_limits = True

                GroupedEpochFFTPlot: probe_fft_plot:
                    pen_color_cycle = 'palettable.cartocolors.qualitative.Bold_2_r'
                    source_name = 'probe'
                    tab_grouping << C.get_names()
                    apply_calibration = True
                    fmt_plot_label_cb = lambda x, s: f'Probe'

                GroupedEpochFFTPlot: elicitor_fft_plot:
                    pen_color_cycle = 'palettable.cartocolors.qualitative.Bold_2'
                    average_mode = 'FFT'
                    source_name = 'elicitor'
                    tab_grouping << C.get_names()
                    apply_calibration = True
                    fmt_plot_label_cb = lambda x, s: f'Elicitor'

        FFTContainer:
            name = 'memr_fft_container'
            label = 'MEMR'
            freq_lb = 4e3
            freq_ub = 32e3

            ViewBox:
                name = 'memr_fft_vb'
                y_mode = 'mouse'
                y_min = -5
                y_max = 5

                GroupedInterleavedMEMRPlot:
                    final_probe = C.elicitor_n
                    name = 'memr_fft_plot'
                    source_name = 'probe'
                    plot_grouping << C.get_names()
                    pen_width = 2
                    pen_color_cycle = 'palettable.scientific.sequential.LaJolla_3'


enamldef InterleavedChirpMEMRManifest(InterleavedMEMRManifest):

    probe = 'chirp'


enamldef InterleavedClickMEMRManifest(InterleavedMEMRManifest):

    probe = 'click'


################################################################################
# Simultaneous MEMR
################################################################################
enamldef SimultaneousClickProbeMixin(ExperimentManifest):

    id = 'simultaneous_click_probe_stim'

    Extension:
        id = EXPERIMENT + '.simultaneous_click_probe.items'
        point = 'psi.context.items'

        Expression:
            parameter = f'probe_click_n'
            expression = 'probe_n'

        Expression:
            parameter = 'probe_click_rate'
            expression = 'probe_rate'

        Expression:
            parameter = 'probe_duration'
            expression = 'probe_bandlimited_click_window'

        Expression:
            parameter = 'probe_bandlimited_click_flb'
            expression = 'probe_fl'

        Expression:
            parameter = 'probe_bandlimited_click_fub'
            expression = 'probe_fh'

        Expression:
            parameter = 'probe_bandlimited_click_level'
            expression = 'probe_level'

        Expression:
            parameter = 'probe_bandlimited_click_window'
            expression = '5e-3'


enamldef SimultaneousChirpProbeMixin(ExperimentManifest):

    id = 'simultaneous_chirp_probe_stim'

    Extension:
        id = EXPERIMENT + '.simultaneous_chirp_probe.items'
        point = 'psi.context.items'

        Expression:
            parameter = 'probe_chirp_n'
            expression = 'probe_n'

        Expression:
            parameter = 'probe_chirp_rate'
            expression = 'probe_rate'

        Expression:
            parameter = 'probe_chirp_start_frequency'
            expression = 'probe_fl'

        Expression:
            parameter = 'probe_chirp_end_frequency'
            expression = 'probe_fh'

        Expression:
            parameter = 'probe_chirp_level'
            expression = 'probe_level'

        ContextRow:
            fmt = ['Probe', probe_duration, 'sec with', probe_window, 'window']
            group_name = 'memr'

            Parameter: probe_duration:
                name = 'probe_duration'
                default = 2e-3

            EnumParameter: probe_window:
                name = 'probe_window'
                choices = {
                    'hann': '"hann"',
                    'boxcar': '"boxcar"',
                }

        Expression:
            parameter = 'probe_chirp_duration'
            expression = 'probe_duration'

        Expression:
            parameter = 'probe_chirp_window'
            expression = 'probe_window'

        Expression:
            parameter = 'probe_chirp_equalize'
            expression = 'probe_max_equalize != 0'

        Expression:
            parameter = 'probe_chirp_max_correction'
            expression = 'probe_max_equalize'

        Expression:
            parameter = 'probe_chirp_audiogram_weighting'
            expression = 'probe_audiogram_weighting'


enamldef SimultaneousMEMRManifest(BaseMEMRManifest):

    # Implements the wideband acoustic reflex as described by Valero and Liberman.
    configure_experiment_cb = partial(configure_memr,
                                      duration_attr='trial_duration',
                                      iti_attr='trial_iti')
    attr probe

    Extension:
        id = EXPERIMENT + '.interleaved_memr.io'
        point = 'psi.controller.io'

        StackRepeats:
            source_name = 'memr_probe'
            name = 'memr_repeat'
            duration = 1 / C.probe_rate

            ExtractStim:
                # Add a bit of padding to capture the tail end of the
                # probe due to acoustic delays
                name = 'probe'
                lb = 0
                ub = C.probe_duration + 1e-3

                ExtractRepeats:
                    name = 'probe_norm'
                    ranges = {
                        'norm': (
                            int(round((C.elicitor_onset - C.norm_window) * C.probe_rate)),
                            int(round(C.elicitor_onset * C.probe_rate)),
                        ),
                        'elicitor': (
                            int(round((C.elicitor_onset + C.elicitor_noise_rise_time) * C.probe_rate)),
                            int(round((C.elicitor_onset + C.elicitor_noise_rise_time + C.norm_window) * C.probe_rate)),
                        )
                    }

        ExtractStim:
            source_name = 'memr_elicitor'
            name = 'elicitor'
            lb = C.elicitor_onset + C.elicitor_noise_rise_time
            ub = C.elicitor_onset + C.elicitor_noise_rise_time + C.elicitor_duration - C.elicitor_noise_rise_time

    Extension:
        id = EXPERIMENT + '.simultaneous_memr.tokens'
        point = 'psi.token.tokens'

        Cos2Envelope:
            name = 'noise'
            BandlimitedFIRNoise:
                hide = ['polarity']

        Repeat: probe:
            name = 'click'
            hide = ['skip_n', 'delay']
            BandlimitedClick:
                hide = ['polarity']

        Repeat: chirp:
            name = 'chirp'
            hide = ['skip_n', 'delay']
            Chirp:
                pass

    Extension:
        id = EXPERIMENT + '.simultaneous_memr.context'
        point = 'psi.context.items'

        ContextRow:
            name = 'trial_info'
            group_name = 'memr'
            fmt = ['Trial', trial_dur, 'sec every', trial_iti, 'sec']

            Parameter: trial_dur:
                name = 'trial_duration'
                default = 11

            Parameter: trial_iti:
                name = 'trial_iti'
                default = 1

        Parameter:
            name = 'trial_n'
            label = 'Number of trials'
            default = 2
            group_name = 'memr'

        Parameter:
            name = 'probe_rate'
            label = 'Probe rate'
            default = 40
            group_name = 'memr'

        Parameter:
            name = 'elicitor_onset'
            label = 'Elicitor onset'
            default = 6
            group_name = 'memr'

        Parameter:
            name = 'elicitor_duration'
            label = 'Elicitor duration'
            default = 3
            group_name = 'memr'

        Parameter:
            name = 'norm_window'
            label = 'Normalization window'
            default = 1
            group_name = 'memr'

        Expression:
            parameter = 'probe_n'
            expression = 'trial_duration * probe_rate'

        Expression:
            parameter = 'elicitor_noise_start_time'
            expression = 'elicitor_onset'

        Expression:
            parameter = 'elicitor_noise_duration'
            expression = 'elicitor_duration'

        Expression:
            parameter = 'elicitor_bandlimited_noise_fl'
            expression = 'elicitor_fl'

        Expression:
            parameter = 'elicitor_bandlimited_noise_fh'
            expression = 'elicitor_fh'

        Expression:
            parameter = 'elicitor_bandlimited_noise_equalize'
            expression = 'elicitor_max_equalize != 0'

        Expression:
            parameter = 'elicitor_bandlimited_noise_seed'
            expression = '1'

        Expression:
            parameter = 'elicitor_noise_rise_time'
            expression = '20e-3'

        Expression:
            parameter = 'elicitor_bandlimited_noise_max_correction'
            expression = 'elicitor_max_equalize'

        Expression:
            parameter = 'elicitor_bandlimited_noise_audiogram_weighting'
            expression = 'elicitor_audiogram_weighting'

    Extension:
        id = EXPERIMENT + '.plots'
        point = 'psi.data.plots'

        EpochTimeContainer: probe_time_container:
            name = 'probe_time_container'
            label = 'Probe waveform'

            max_buttons = 4
            fmt_button_cb << \
                C.get_selector().get_formatter(probe_plot.tab_grouping)

            ViewBox: probe_time_vb:
                name = 'probe_time_vb'
                y_mode = 'mouse'
                save_limits = True

                GroupedEpochAveragePlot: probe_plot:
                    source_name = 'probe_norm'
                    plot_grouping = ['range']
                    plot_keys = [('norm',), ('elicitor',)]
                    autogenerate_keys = 'tab'
                    tab_grouping << C.get_names()

        FFTContainer: probe_fft_container:
            name = 'probe_fft_container'
            label = 'Probe and Elicitor PSD'
            freq_lb = 0.5e3
            freq_ub = 50e3

            max_buttons = 4
            fmt_button_cb << \
                C.get_selector().get_formatter(probe_fft_plot.tab_grouping)

            ViewBox:
                name = 'probe_fft_vb'
                y_mode = 'mouse'
                save_limits = True

                GroupedEpochFFTPlot: probe_fft_plot:
                    source_name = 'probe_norm'
                    plot_grouping = ['range']
                    plot_keys = [('norm',), ('elicitor',)]
                    autogenerate_keys = 'tab'
                    tab_grouping << C.get_names()
                    apply_calibration = True
                    average_mode = 'time'

                GroupedEpochFFTPlot: elicitor_fft_plot:
                    source_name = 'elicitor'
                    tab_grouping << C.get_names()
                    apply_calibration = True
                    pen_color_cycle = ['k']
                    waveform_averages = 10

        FFTContainer:
            name = 'memr_fft_container'
            label = 'MEMR'
            freq_lb = 4e3
            freq_ub = 32e3

            ViewBox:
                name = 'memr_fft_vb'
                y_mode = 'mouse'
                y_min = -3
                y_max = 3

                GroupedSimultaneousMEMRPlot:
                    name = 'memr_fft_plot'
                    source_name = 'probe_norm'
                    plot_grouping << C.get_names()
                    pen_width = 2
                    pen_color_cycle = 'palettable.scientific.sequential.LaJolla_3'
