import logging
log = logging.getLogger(__name__)

from copy import deepcopy
import json
import os
from pathlib import Path
import subprocess
import time

from atom.api import Atom, Bool, Dict, Enum, Int, List, Str
from enaml.core.api import Looper
from enaml.layout.api import align, hbox, spacer, vbox
from enaml.stdlib.message_box import critical
from enaml.widgets.api import (
    Action, ActionGroup, ButtonGroup, CheckBox, Container, Field, FileDialogEx,
    Form, GroupBox, HGroup, Label, MainWindow, Menu, MenuBar, Notebook,
    ObjectCombo, Page, PopupView, PushButton, VGroup,
)

from psi import get_config, get_config_folder
from psi.application import list_preferences
from psi.experiment.api import paradigm_manager

from cftscal.api import (
    list_input_amplifier_connections, list_starship_connections,
    microphone_manager, starship_manager
)
from cfts.paradigms import cfts
from cftscal.plugins.widgets import AddItem


DATA_ROOT = get_config('DATA_ROOT')
PROC_ROOT = get_config('PROCESSED_ROOT')
CFTS_ROOT = get_config('CFTS_ROOT')


enamldef AddItem(PopupView): popup:

    attr settings
    window_type = 'popup'
    arrow_size = 20
    arrow_edge = 'top'
    alias label: label.text

    Container:
        constraints = [
            vbox(
                hbox(label, field),
                hbox(spacer(0), pb_ok, pb_cancel, spacing=0)
            ),
            align('v_center', label, field),
            align('v_center', pb_ok, pb_cancel),
            align('width', pb_ok, pb_cancel),
        ]

        Label: label:
            pass
        Field: field:
            pass
        PushButton: pb_ok:
            text = 'OK'
            enabled << bool(field.text)
            clicked ::
                items = settings.standard_notes[:]
                items.append(field.text)
                settings.standard_notes = items
                settings.standard_note = field.text
                popup.close()

        PushButton: pb_cancel:
            text = 'Cancel'
            clicked ::
                popup.close()


class Experiment(Atom):

    label = Str()
    paradigm = Str()
    preference = Str()
    plugins = List(Str())
    modes = List(Str())

    #: Supplemental note to append based on the button clicked.
    mode_notes = Dict()

    def _default_mode_notes(self):
        return {m: '' for m in self.modes}

    def _default_modes(self):
        return ['Run']

    def __init__(self, paradigm, plugins, preference, **kwargs):
        # Make sure the plugins saved to the config file are valid plugins (we
        # sometimes remove or rename plugins). If the plugin is no longer
        # valid, remove it. If the plugin is required, remove it as a plugin
        # that the user can select from in the GUI (since it automatically gets
        # loaded).
        valid_plugins = paradigm_manager.get_paradigm(paradigm).plugins
        for plugin in plugins[:]:
            for valid_plugin in valid_plugins:
                if plugin == valid_plugin.name and not valid_plugin.required:
                    break
            else:
                plugins.remove(plugin)

        # We only save preference name, not the full path to the preference. We
        # need to restore the full path to the preference by scanning through
        # the list of avaialble preferences. This allows for portability across
        # systems.
        preference = Path(preference)
        for valid_preference in list_preferences(paradigm):
            if valid_preference.stem == preference.stem:
                preference = str(valid_preference)
                break
        else:
            log.warning('Invalid preference requested for %s: %s', paradigm, preference)
            preference = ''
        super().__init__(paradigm=paradigm, plugins=plugins,
                         preference=preference, **kwargs)

    def __getstate__(self):
        state = super().__getstate__()
        state['preference'] = Path(state['preference']).name
        return state


class Settings(Atom):

    logging_level = Enum('trace', 'debug', 'info', 'warning', 'error')('info')
    animal = Str()
    ear = Enum('left', 'right')
    experimenter = Str()
    note = Str()
    standard_notes = List(Str())
    standard_note = Str()

    monitor_sequence = List(Experiment)
    experiment_sequence = List(Experiment)
    current_queue = List(Experiment)

    starship_config = Dict()
    cal_mic_config = Dict()
    record_cal_mic = Bool(False)
    record_output_monitor = Bool(False)
    input_amp_config = Dict()

    duration = Int()

    def _default_standard_notes(self):
        return ['']

    def find_starship(self, ear, monaural=True):
        '''
        Return starship configured for specified ear

        Parameters
        ----------
        ear : {'left', 'right'}
            Ear to locate starship for
        monaural : bool
            If True, will load the starship marked for either ear if it exists
            and it can't find a starship specifically designated for the
            requested ear.
        '''
        starship_to_use = set()
        for k, v in self.starship_config.items():
            if v['ear'] == ear:
                starship_to_use.add(k)
            elif v['ear'] == 'either' and monaural:
                starship_to_use.add(k)
        if len(starship_to_use) != 1:
            raise ValueError('Starships incorrectly configured')
        return next(iter(starship_to_use))

    def run_experiment(self, experiment, mode, save=True):
        amp_input_name = self.input_amp_config['input_name']
        env = {
            'CFTS_INPUT_AMPLIFIER': amp_input_name,
            f'CFTS_INPUT_AMPLIFIER_{amp_input_name.upper()}_GAIN': str(self.input_amp_config['gain']),
            f'CFTS_INPUT_AMPLIFIER_{amp_input_name.upper()}_FREQ_LB': str(self.input_amp_config['freq_lb']),
            f'CFTS_INPUT_AMPLIFIER_{amp_input_name.upper()}_FREQ_UB': str(self.input_amp_config['freq_ub']),
        }
        for k, v in self.starship_config.items():
            cal_string = v['calibration'].get_current_calibration().to_string()
            env[f'CFTS_STARSHIP_{k.upper()}'] = cal_string
            env[f'CFTS_STARSHIP_{k.upper()}_GAIN'] = str(v['gain'])

        env['CFTS_TEST_STARSHIP'] = self.find_starship(self.ear, True)
        if mode.lower() == 'run':
            pass
        elif mode.lower() == 'ipsi':
            env['CFTS_NONTEST_STARSHIP'] = env['CFTS_TEST_STARSHIP']
        elif mode.lower() == 'contra':
            try:
                nontest_ear = 'right' if self.ear == 'left' else 'left'
                env['CFTS_NONTEST_STARSHIP'] = self.find_starship(nontest_ear, False)
            except ValueError:
                pass
        elif mode.lower() == 'binaural':
            env['CFTS_LEFT_STARSHIP'] = self.find_starship('left', False)
            env['CFTS_RIGHT_STARSHIP'] = self.find_starship('right', False)

        filename = f'{{date_time}} {self.experimenter} {self.animal} {self.ear} {self.note} {self.standard_note} {experiment.mode_notes[mode]} {experiment.paradigm}'
        filename = ' '.join(filename.split())
        args = ['psi', experiment.paradigm]
        if save:
            args.append(str(DATA_ROOT / filename))
        args.extend([
            '--preferences', experiment.preference,
            '--debug-level-console', self.logging_level.upper(),
        ])
        for plugin in experiment.plugins:
            args.extend(['--plugin', plugin])

        if self.record_cal_mic:
            env['CFTS_CAL_MIC'] = self.cal_mic_config['microphone'].get_current_calibration().to_string()
            env['CFTS_CAL_MIC_GAIN'] = str(self.cal_mic_config['gain'])
            env['CFTS_CAL_MIC_STARSHIP'] = self.cal_mic_config['starship']
            args.extend(['--plugin', 'calibration_microphone'])

        if self.record_output_monitor:
            args.extend(['--plugin', 'output_monitor'])

        print(env)
        print(' '.join(args))
        start_time = time.time()
        subprocess.check_output(args, env=dict(os.environ, **env))
        self.duration = int(round(time.time() - start_time))

    def save_config(self, filename):
        info = {
            'ear': self.ear,
            'logging_level': self.logging_level,
            'starship_config': self.starship_config,
            'record_cal_mic': self.record_cal_mic,
            'cal_mic_config': {
                'microphone': self.cal_mic_config['microphone'].name,
                'gain': self.cal_mic_config['gain'],
                'starship': self.cal_mic_config['starship'],
            },
            'input_amp_config': {
                'input_name': self.input_amp_config['input_name'],
                'gain': self.input_amp_config['gain'],
                'freq_lb': self.input_amp_config['freq_lb'],
                'freq_ub': self.input_amp_config['freq_ub'],
            },
            'standard_notes': self.standard_notes,
        }
        info['experiment_sequence'] = [e.__getstate__() for e in self.experiment_sequence]
        info['monitor_sequence'] = [e.__getstate__() for e in self.monitor_sequence]
        info['starship_config'] = {}
        for k, v in self.starship_config.items():
            info['starship_config'][k] = {
                'ear': v['ear'],
                'calibration': v['calibration'].name,
                'gain': v['gain'],
            }

        filename = Path(filename)
        filename.write_text(json.dumps(info, indent=2))

    def load_config(self, filename):
        filename = Path(filename)
        info = json.loads(filename.read_text())
        info.pop('experimenter', None)
        info['experiment_sequence'] = [Experiment(**s) for s in info['experiment_sequence']]
        info['monitor_sequence'] = [Experiment(**s) for s in info['monitor_sequence']]
        for k, v in info.items():
            setattr(self, k, v)

        # Update the starship config list to reflect current starship connections
        starships = list_starship_connections()
        for starship in starships:
            if starship not in self.starship_config:
                self.starship_config[starship] = {
                    'ear': 'not used',
                    'calibration': None,
                    'gain': 40,
                }
        for starship in list(self.starship_config.keys()):
            if starship not in starships:
                self.starship_config.pop(starship)
            else:
                s = self.starship_config[starship]
                s.setdefault('gain', 40)
                s.setdefault('calibration', None)
                s.setdefault('ear', 'not used')
                if s['calibration'] is not None:
                    s['calibration'] = starship_manager.get_object(s['calibration'])

        # Add microphone in if it was not in a previously-saved config.
        if 'microphone' not in self.cal_mic_config:
            self.cal_mic_config['microphone'] = None
        if 'gain' not in self.cal_mic_config:
            self.cal_mic_config['gain'] = 20
        if 'starship' not in self.cal_mic_config:
            self.cal_mic_config['starship'] = next(iter(starships))

        if self.cal_mic_config['microphone'] is not None:
            self.cal_mic_config['microphone'] = \
                microphone_manager.get_object(self.cal_mic_config['microphone'])

        if 'input_name' not in self.input_amp_config:
            self.input_amp_config['input_name'] = None
        if 'gain' not in self.input_amp_config:
            self.input_amp_config['gain'] = 50e3
        if 'freq_lb' not in self.input_amp_config:
            self.input_amp_config['freq_lb'] = 10
        if 'freq_ub' not in self.input_amp_config:
            self.input_amp_config['freq_ub'] = 10e3


enamldef PluginPopup(PopupView): popup:
    attr experiment
    attr available_plugins
    arrow_size = 20
    VGroup:
        Form:
            padding = 0
            Looper:
                iterable = experiment.mode_notes.items()
                Label:
                    text = f'{loop_item[0].capitalize()} note'
                Field:
                    text = loop_item[1]
                    text ::
                        experiment.mode_notes[loop_item[0]] = text
        Looper:
            iterable = available_plugins
            CheckBox:
                checked = bool(loop_item.name in experiment.plugins)
                checked ::
                    if checked:
                        if loop_item.name not in experiment.plugins:
                            experiment.plugins.append(loop_item.name)
                    else:
                        experiment.plugins.remove(loop_item.name)
                text = loop_item.title


enamldef ExperimentSequence(Container): experiment_box:

    attr start_enabled = True
    attr save = True
    attr sequence

    layout_constraints => ():
        # Align the subwidgets vertically
        subwidgets = [w.children for w in self.visible_widgets()]
        constraints = [vbox(*self.visible_widgets())]
        constraints.extend([align('width', *c) for c in zip(*subwidgets)])
        return constraints

    Looper:
        iterable << experiment_box.sequence

        Container:
            share_layout = True
            constraints = [hbox(*children), align('v_center', *self.visible_widgets())]
            padding = 0

            Label:
                text = loop_item.label

            HGroup:
                padding = 0
                spacing = 0
                enabled << experiment_box.start_enabled

                Looper: mode_loop:
                    attr experiment = loop_item
                    iterable << experiment.modes

                    PushButton:
                        text = loop_item.capitalize()
                        clicked ::
                            try:
                                settings.run_experiment(mode_loop.experiment, loop_item,
                                                        save=experiment_box.save)
                            except Exception as e:
                                log.exception(e)
                                critical(experiment_box, 'Error starting experiment', str(e))
                            # Update the preferences in case new ones were created
                            preferences.items = [str(p) for p in list_preferences(mode_loop.experiment.paradigm)]

            ObjectCombo: preferences:
                items = [str(p) for p in list_preferences(loop_item.paradigm)]
                selected := loop_item.preference
                to_string = lambda x: Path(x).stem

            PushButton:
                attr plugins = [p for p in paradigm_manager.get_paradigm(loop_item.paradigm).plugins \
                                if not p.required and p.name != 'calibration_microphone']
                constraints = [width == 30]
                text = '⚙'
                visible = bool(plugins)
                clicked ::
                    popup = PluginPopup(parent=self, experiment=loop_item, available_plugins=plugins)
                    popup.show()

            PushButton:
                constraints = [width == 30]
                text = '+'
                clicked ::
                    new_item = deepcopy(loop_item)
                    queue = main.settings.current_queue[:]
                    queue.append(new_item)
                    main.settings.current_queue = queue
                    print(main.settings.current_queue)


enamldef ExperimentInfo(GroupBox):
    title = 'Experiment Info'

    constraints = [
        vbox(
            hbox(experimenter_label, experimenter_field),
            hbox(animal_label, animal_field, hbox(l_button, r_button, spacing=0)),
            hbox(note_label, note_field),
            hbox(standard_note_label, standard_note_field, hbox(add_note, remove_note, spacing=0)),
            hbox(spacer(0), pb_raw, pb_proc),
        ),
        align('right', experimenter_label, animal_label, note_label, standard_note_label),
        align('left', experimenter_label, animal_label, note_label, standard_note_label),
        align('v_center', experimenter_label, experimenter_field),
        align('v_center', animal_label, animal_field, l_button, r_button),
        align('v_center', note_label, note_field),
        align('v_center', standard_note_label, standard_note_field, add_note, remove_note),
        align('v_center', pb_raw, pb_proc),
        add_note.width == 30,
        remove_note.width == 30,
        l_button.width == 30,
        r_button.width == 30,
        pb_raw.width == 90,
        pb_proc.width == 90,
    ]

    ButtonGroup: ear_group:
        pass

    Label: experimenter_label:
        text = 'Experimenter'

    Field: experimenter_field:
        text := settings.experimenter

    Label: animal_label:
        text = 'Animal'

    Field: animal_field:
        text := settings.animal

    Label: note_label:
        text = 'Note'

    Field: note_field:
        text := settings.note

    Label: standard_note_label:
        text = 'Standard notes'

    ObjectCombo: standard_note_field:
        items << settings.standard_notes
        selected := settings.standard_note

    PushButton: add_note:
        text = '+'
        clicked ::
            popup = AddItem(parent=self, settings=settings)
            popup.show()

    PushButton: remove_note:
        enabled << bool(settings.standard_note)
        text = '-'
        clicked ::
            items = settings.standard_notes[:]
            items.remove(settings.standard_note)
            settings.standard_note = ''
            settings.standard_notes = items

    PushButton: l_button:
        text = 'L'
        checkable = True
        group = ear_group
        checked << settings.ear == 'left'
        checked ::
            settings.ear = 'left'

    PushButton: r_button:
        text = 'R'
        checkable = True
        group = ear_group
        checked << settings.ear == 'right'
        checked ::
            settings.ear = 'right'

    PushButton: pb_raw:
        text = '📂 Raw'
        clicked ::
            os.startfile(DATA_ROOT)

    PushButton: pb_proc:
        text = '📂 Processed'
        clicked ::
            os.startfile(PROC_ROOT)


enamldef Main(MainWindow): main:

    title = 'Cochlear Function Test Suite'

    attr settings = Settings()

    MenuBar:
        Menu:
            title = '&File'
            Action:
                text = 'Load config\tCtrl+O'
                triggered ::
                    path = CFTS_ROOT / 'cfts-launcher'
                    path.mkdir(exist_ok=True)
                    filename = FileDialogEx.get_open_file_name(
                        current_path=str(path),
                        name_filters=['Experiment Settings (*.json)'],
                    )
                    settings.load_config(filename)
            Action:
                text = 'Save config\tCtrl+O'
                triggered ::
                    path = CFTS_ROOT / 'cfts-launcher'
                    path.mkdir(exist_ok=True)
                    filename = FileDialogEx.get_save_file_name(
                        current_path=str(path),
                        name_filters=['Experiment Settings (*.json)'],
                    )
                    settings.save_config(filename)
        Menu:
            title = '&Debug'
            Menu:
                title = 'Logging Level'
                ActionGroup:
                    Looper:
                        iterable = settings.get_member('logging_level').items
                        Action:
                            checkable = True
                            text = loop_item
                            checked ::
                                settings.logging_level = loop_item
                            checked << settings.logging_level == loop_item
            Action:
                text = '&Record calibration microphone'
                checkable = True
                checked := settings.record_cal_mic
            Action:
                text = '&Record output monitor signal'
                checkable = True
                checked := settings.record_output_monitor

    Container:

        constraints = [
            vbox(
                starship_info,
                monitor_box,
                experiment_info,
                experiment_nb,
                experiment_stats,
            ),
            # Align the widths of the first three elements in the
            # experiment/monitor box. The first three elements represent the
            # first "row" of widgets in each box. Once we align those, the rest
            # fall into line.
            #align('width', monitor_box.children[0].children[0], experiment_box.children[0].children[0]),
            #align('width', monitor_box.children[0].children[1], experiment_box.children[0].children[1]),
            #align('width', monitor_box.children[0].children[2], experiment_box.children[0].children[2]),
            #align('width', monitor_box.children[0].children[3], experiment_box.children[0].children[3]),
        ]

        GroupBox: starship_info:
            title = 'Equipment Configuration'
            flat = True
            share_layout = True

            layout_constraints => ():
                header = children[:3]
                widgets = [c for c in children[3:] \
                           if not isinstance(c, Looper) \
                           and not isinstance(c, Container)]
                extra_widgets = [c for c in children[3:] if isinstance(c, Container)]
                extra_labels = [w.children[0] for w in extra_widgets]
                zipped = list(zip(
                    widgets[0::4],   # labels
                    widgets[1::4],   # ear select
                    widgets[2::4],   # starship select
                    widgets[3::4],   # gain select
                ))
                constraints = [
                    vbox(
                        hbox(*header),
                        *[hbox(*r) for r in zipped],
                        *extra_widgets,
                    ),
                ]
                constraints.extend([align('v_center', *r) for r in zipped])
                constraints.extend([
                    align('left', header[0], *widgets[1::4]),
                    align('left', header[1], *widgets[2::4]),
                    align('left', header[2], *widgets[3::4]),
                    align('left', eeg_label, *widgets[0::4]),
                    align('left', eeg_input_name, header[0]),
                ])
                return constraints

            Label:
                text = 'Ear'
            Label:
                text = 'Calibration'
            Label:
                text = 'Gain'

            Looper:
                iterable << settings.starship_config.keys()
                Label:
                    text = f'Starship {loop_item}'
                ObjectCombo:
                    items = ['either', 'left', 'right', 'not used']
                    selected << settings.starship_config[loop_item]['ear']
                    selected ::
                        settings.starship_config[loop_item]['ear'] = selected
                ObjectCombo:
                    items << sorted(starship_manager.list_objects())
                    selected << settings.starship_config[loop_item]['calibration']
                    selected ::
                        settings.starship_config[loop_item]['calibration'] = selected
                ObjectCombo:
                    items = [20, 40]
                    selected << settings.starship_config[loop_item]['gain']
                    selected ::
                        settings.starship_config[loop_item]['gain'] = selected

            Label:
                text = 'Cal. mic.'
                visible << settings.record_cal_mic

            Label:
                text = ''
                visible << settings.record_cal_mic

            ObjectCombo: selected_mic:
                items = sorted(microphone_manager.list_objects())
                selected << settings.cal_mic_config['microphone']
                selected ::
                    settings.cal_mic_config['microphone'] = selected
                visible << settings.record_cal_mic

            ObjectCombo:
                items = [-20, -10, 0, 10, 20, 30, 40, 50]
                selected << settings.cal_mic_config['gain']
                selected ::
                    settings.cal_mic_config['gain'] = selected
                visible << settings.record_cal_mic

            Container:
                padding = 0
                share_layout = True

                constraints = [
                    hbox(*self.visible_widgets()),
                    align('v_center', *self.visible_widgets()),
                ]

                Label: eeg_label:
                    text ='EEG amplifier'

                ObjectCombo: eeg_input_name:
                    attr choices = list_input_amplifier_connections()
                    attr choices_lookup << {v: k for k, v in choices.items()}
                    items << list(choices_lookup)
                    selected << settings.input_amp_config['input_name']
                    selected ::
                        settings.input_amp_config['input_name'] = selected
                    to_string = choices_lookup.get

                ObjectCombo: eeg_gain:
                    items = [10e3, 20e3, 50e3, 100e3]
                    selected << settings.input_amp_config['gain']
                    selected ::
                        settings.input_amp_config['gain'] = selected
                    to_string = lambda x: f'{x:.0f} ✕'

                ObjectCombo: eeg_freq_lb:
                    items = [10, 300]
                    selected << settings.input_amp_config['freq_lb']
                    selected ::
                        settings.input_amp_config['freq_lb'] = selected
                    to_string = lambda x: f'{x} Hz'

                Label: eeg_to_label:
                    text = 'to'

                ObjectCombo: eeg_freq_ub:
                    items = [3000, 10000]
                    selected << settings.input_amp_config['freq_ub']
                    selected ::
                        settings.input_amp_config['freq_ub'] = selected
                    to_string = lambda x: f'{x} Hz'

        ExperimentInfo: experiment_info:
            pass

        GroupBox: monitor_box:
            title = 'Experiment checks (not saved)'
            ExperimentSequence:
                share_layout = True
                sequence << settings.monitor_sequence
                save = False

        Notebook: experiment_nb:
            tab_style = 'preferences'
            Page:
                title = 'Experiments (saved)'
                closable = False
                Container:
                    share_layout = True
                    ExperimentSequence: experiment_box:
                        share_layout = True
                        start_enabled << (bool(settings.animal) and bool(settings.experimenter))
                        sequence << settings.experiment_sequence
            Page:
                title = 'Experiment queues'
                closable = False
                Container:
                    share_layout = True
                    ObjectCombo:
                        pass
                    ExperimentSequence:
                        sequence << settings.current_queue

        GroupBox: experiment_stats:
            title = 'Experiment Info'
            flat = True
            share_layout = True

            Label:
                text << f'Last run took {settings.duration//60} min and {settings.duration % 60} sec'
