import logging
log = logging.getLogger(__name__)
logging.basicConfig(level='DEBUG')

from copy import deepcopy
import json
import os
from pathlib import Path
import subprocess
import time

from atom.api import (
    Atom, Bool, Dict, Enum, Int, List, Property, Str, Typed, Value
)
from enaml.application import timed_call
from enaml.core.api import Conditional, Looper
from enaml.layout.api import align, hbox, spacer, vbox
from enaml.stdlib.message_box import critical
from enaml.widgets.api import (
    Action, ActionGroup, ButtonGroup, CheckBox, Container, Field, FileDialogEx,
    Form, GroupBox, HGroup, Label, MainWindow, Menu, MenuBar, Notebook,
    ObjectCombo, Page, PopupView, PushButton, VGroup,
)

from psi import get_config, get_config_folder
from psi.experiment.api import paradigm_manager
from psi.paradigms.core.websocket_mixins import WebsocketServerPlugin

from cftscal.api import (
    list_input_amplifier_connections, list_starship_connections,
    microphone_manager, starship_manager
)
from cfts.paradigms import cfts
from cftscal.plugins.widgets import AddItem


DATA_ROOT = get_config('DATA_ROOT')
PROC_ROOT = get_config('PROCESSED_ROOT')
CFTS_ROOT = get_config('CFTS_ROOT')


class Experiment(Atom):

    label = Str()
    paradigm = Value()
    preference = Str()

    #: Plugins selected for load
    plugins = List(Str())

    #: All plugins
    available_plugins = List(Str())

    #: Supplemental note to append based on the button clicked.
    mode_notes = Dict()

    def _default_mode_notes(self):
        return {}

    def __init__(self, paradigm, plugins, preference, **kwargs):
        # Make sure the plugins saved to the config file are valid plugins (we
        # sometimes remove or rename plugins). If the plugin is no longer
        # valid, remove it. If the plugin is required, remove it as a plugin
        # that the user can select from in the GUI (since it automatically gets
        # loaded).
        paradigm = paradigm_manager.get_paradigm(paradigm)
        for plugin in plugins[:]:
            for valid_plugin in paradigm.plugins:
                if plugin == valid_plugin.id and not valid_plugin.required:
                    break
            else:
                plugins.remove(plugin)

        # We only save preference name, not the full path to the preference. We
        # need to restore the full path to the preference by scanning through
        # the list of avaialble preferences. This allows for portability across
        # systems.
        preference = Path(preference)
        for valid_preference in paradigm.list_preferences():
            if valid_preference.stem == preference.stem:
                preference = str(valid_preference)
                break
        else:
            log.warning('Invalid preference requested for %s: %s', paradigm,
                        preference)
            preference = ''

        # Remove legacy modes since we changed how this is handled (it was
        # always a hack to put in the file).
        kwargs.pop('modes', None)

        super().__init__(paradigm=paradigm, plugins=plugins,
                         preference=preference, **kwargs)

    def __getstate__(self):
        state = super().__getstate__()
        state['preference'] = Path(state['preference']).name
        return state

    def freeze(self, mode, ear='either'):
        return FrozenExperiment(
            label=self.label,
            paradigm=self.paradigm,
            preference=self.preference,
            plugins=self.plugins,
            modes=self.modes,
            mode_notes=self.mode_notes,
            mode=mode,
            ear=ear,
        )


class FrozenExperiment(Experiment):
    '''
    Subclass of Experiment in which we have frozen the ear and mode (used for queues).
    '''
    mode = Str()

    #: If either, then ear will be drawn from what is selected.
    ear = Enum('selected', 'left', 'right')


class Settings(Atom):

    logging_level = Enum('trace', 'debug', 'info', 'warning', 'error')('info')
    animal = Str()
    ear = Enum('left', 'right')
    experimenter = Str()
    note = Str()
    standard_notes = List(Str())
    standard_note = Str()

    monitor_sequence = List(Experiment)
    experiment_sequence = List(Experiment)

    #: Dictionary of queue name to lists of FrozenExperiment
    queues = Dict()

    #: Currently selected queue
    current_queue_name = Str()

    #: Currently selected queue (this has to be broken out from queues to
    #: enable proper change notifications, I think).
    current_queue = List(Experiment)

    starship_config = Dict()

    #: String indicating starship configuration. Either mono (indicating that
    #: we have a single starship that is used for either ear) or stereo (one
    #: starship per ear).
    audio_mode = Property()

    #: Currently active subprocess
    active_subprocess = Value()

    #: Is an experiment currently running?
    experiment_running = Bool(False)

    def _get_audio_mode(self):
        if self.find_starship('right', True) == self.find_starship('left', True):
            return 'mono'
        else:
            return 'stereo'

    cal_mic_config = Dict()
    record_cal_mic = Bool(False)
    record_output_monitor = Bool(False)
    record_body_temperature = Bool(True)

    #: If True, ensure inear calibration plugin is loaded if available.
    run_inear_calibration = Bool(True)
    input_amp_config = Dict()

    duration = Int()
    ws_server = Typed(WebsocketServerPlugin)

    def __init__(self, *args, **kw):
        super().__init__(*args, **kw)
        self.ws_server = WebsocketServerPlugin(
            recv_cb=self.recv_msg,
            connect_cb=self.set_event_filter,
        )
        self.ws_server.start_thread()

    def set_event_filter(self):
        log.info('SETTING EVENT FILTER')
        self.ws_server.send_message({
            'command': 'websocket.set_event_filter',
            'parameters': {'event_filter': 'experiment_end|window_closed|websocket_connected'},
        })

    def recv_msg(self, message):
        if message['event'] == 'experiment_end':
            self.experiment_complete()
        elif message['event'] == 'window_closed':
            self.experiment_complete()
        elif message['event'] == 'websocket_connected':
            print('MESSAGE!!!!')

    def _default_standard_notes(self):
        return ['']

    def find_starship(self, ear, monaural=True):
        '''
        Return starship configured for specified ear

        Parameters
        ----------
        ear : {'left', 'right'}
            Ear to locate starship for
        monaural : bool
            If True, will load the starship marked for either ear if it exists
            and it can't find a starship specifically designated for the
            requested ear.
        '''
        starship_to_use = set()
        for k, v in self.starship_config.items():
            if v['ear'] == ear:
                starship_to_use.add(k)
            elif v['ear'] == 'either' and monaural:
                starship_to_use.add(k)
        if len(starship_to_use) != 1:
            raise ValueError('Starships incorrectly configured')
        return next(iter(starship_to_use))

    def build_experiment(self, experiment, mode, save=True):
        '''
        Build the experiment arguments and environment for launching in subprocess
        '''
        amp_input_name = self.input_amp_config['input_name']
        env = {
            'CFTS_INPUT_AMPLIFIER': amp_input_name,
            f'CFTS_INPUT_AMPLIFIER_{amp_input_name.upper()}_GAIN': str(self.input_amp_config['gain']),
            f'CFTS_INPUT_AMPLIFIER_{amp_input_name.upper()}_FREQ_LB': str(self.input_amp_config['freq_lb']),
            f'CFTS_INPUT_AMPLIFIER_{amp_input_name.upper()}_FREQ_UB': str(self.input_amp_config['freq_ub']),
        }
        for k, v in self.starship_config.items():
            cal_string = v['calibration'].get_current_calibration().to_string()
            env[f'CFTS_STARSHIP_{k.upper()}'] = cal_string
            env[f'CFTS_STARSHIP_{k.upper()}_GAIN'] = str(v['gain'])

        env['CFTS_TEST_STARSHIP'] = self.find_starship(self.ear, True)
        if mode.lower() == 'run':
            pass
        elif mode.lower() == 'ipsi':
            env['CFTS_NONTEST_STARSHIP'] = env['CFTS_TEST_STARSHIP']
        elif mode.lower() == 'contra':
            try:
                nontest_ear = 'right' if self.ear == 'left' else 'left'
                env['CFTS_NONTEST_STARSHIP'] = self.find_starship(nontest_ear, False)
            except ValueError:
                pass
        elif mode.lower() == 'binaural':
            env['CFTS_LEFT_STARSHIP'] = self.find_starship('left', False)
            env['CFTS_RIGHT_STARSHIP'] = self.find_starship('right', False)

        mode_note = experiment.mode_notes.get(mode, '')
        filename = f'{{date_time}} {self.experimenter} {self.animal} {self.ear} {self.note} {self.standard_note} {mode_note} {experiment.paradigm}'
        filename = ' '.join(filename.split())
        args = ['psi', experiment.paradigm.name]
        if save:
            args.append(str(DATA_ROOT / filename))
        args.extend([
            '--preferences', experiment.preference,
            '--debug-level-console', self.logging_level.upper(),
        ])
        for plugin in experiment.plugins:
            args.extend(['--plugin', plugin])

        if self.record_cal_mic:
            env['CFTS_CAL_MIC'] = self.cal_mic_config['microphone'].get_current_calibration().to_string()
            env['CFTS_CAL_MIC_GAIN'] = str(self.cal_mic_config['gain'])
            env['CFTS_CAL_MIC_STARSHIP'] = self.cal_mic_config['starship']
            args.extend(['--plugin', 'calibration_microphone'])

        if self.record_output_monitor:
            args.extend(['--plugin', 'output_monitor'])

        if self.record_body_temperature:
            for p in experiment.paradigm.plugins:
                if p.id  == 'temperature':
                    args.extend(['--plugin', 'temperature'])
                    break
            else:
                log.warning('No temperature plugin available for %s',
                            experiment.paradigm.name)

        if self.run_inear_calibration:
            for p in experiment.paradigm.plugins:
                if p.id.endswith('_inear_calibration'):
                    args.extend(['--plugin', p.id])
                    break
            else:
                log.warning('No in-ear plugin available for %s',
                            experiment.paradigm.name)


        return args, env

    def run_experiment(self, experiment, mode, save=True):
        args, env = self.build_experiment(experiment, mode, save)
        print(env)
        print(' '.join(args))

        #start_time = time.time()
        #self.duration = int(round(time.time() - start_time))
        self.active_subprocess = subprocess.Popen(args, env=dict(os.environ, **env))
        self.experiment_running = True
        timed_call(1000, self.check_experiment_status)

    def check_experiment_status(self):
        if self.experiment_running and self.active_subprocess.poll() is not None:
            self.experiment_running = False
        else:
            timed_call(1000, self.check_experiment_status)

    def experiment_complete(self):
        self.experiment_running = False

    def save_config(self, filename):
        info = {
            'ear': self.ear,
            'logging_level': self.logging_level,
            'starship_config': self.starship_config,
            'record_cal_mic': self.record_cal_mic,
            'cal_mic_config': {
                'microphone': self.cal_mic_config['microphone'].name,
                'gain': self.cal_mic_config['gain'],
                'starship': self.cal_mic_config['starship'],
            },
            'input_amp_config': {
                'input_name': self.input_amp_config['input_name'],
                'gain': self.input_amp_config['gain'],
                'freq_lb': self.input_amp_config['freq_lb'],
                'freq_ub': self.input_amp_config['freq_ub'],
            },
            'standard_notes': self.standard_notes,
        }
        info['experiment_sequence'] = [e.__getstate__() for e in self.experiment_sequence]
        info['monitor_sequence'] = [e.__getstate__() for e in self.monitor_sequence]
        info['starship_config'] = {}
        for k, v in self.starship_config.items():
            info['starship_config'][k] = {
                'ear': v['ear'],
                'calibration': v['calibration'].name,
                'gain': v['gain'],
            }

        filename = Path(filename)
        filename.write_text(json.dumps(info, indent=2))

    def load_config(self, filename):
        filename = Path(filename)
        info = json.loads(filename.read_text())
        info.pop('experimenter', None)
        info['experiment_sequence'] = [Experiment(**s) for s in info['experiment_sequence']]
        info['monitor_sequence'] = [Experiment(**s) for s in info['monitor_sequence']]
        for k, v in info.items():
            setattr(self, k, v)

        # Update the starship config list to reflect current starship connections
        starships = list_starship_connections()
        for starship in starships:
            if starship not in self.starship_config:
                self.starship_config[starship] = {
                    'ear': 'not used',
                    'calibration': None,
                    'gain': 40,
                }
        for starship in list(self.starship_config.keys()):
            if starship not in starships:
                self.starship_config.pop(starship)
            else:
                s = self.starship_config[starship]
                s.setdefault('gain', 40)
                s.setdefault('calibration', None)
                s.setdefault('ear', 'not used')
                if s['calibration'] is not None:
                    s['calibration'] = starship_manager.get_object(s['calibration'])

        # Add microphone in if it was not in a previously-saved config.
        if 'microphone' not in self.cal_mic_config:
            self.cal_mic_config['microphone'] = None
        if 'gain' not in self.cal_mic_config:
            self.cal_mic_config['gain'] = 20
        if 'starship' not in self.cal_mic_config:
            self.cal_mic_config['starship'] = next(iter(starships))

        if self.cal_mic_config['microphone'] is not None:
            self.cal_mic_config['microphone'] = \
                microphone_manager.get_object(self.cal_mic_config['microphone'])

        if 'input_name' not in self.input_amp_config:
            self.input_amp_config['input_name'] = None
        if 'gain' not in self.input_amp_config:
            self.input_amp_config['gain'] = 50e3
        if 'freq_lb' not in self.input_amp_config:
            self.input_amp_config['freq_lb'] = 10
        if 'freq_ub' not in self.input_amp_config:
            self.input_amp_config['freq_ub'] = 10e3


enamldef PluginPopup(PopupView): popup:
    attr experiment
    attr available_plugins
    attr modes
    arrow_size = 20
    VGroup:
        Form:
            padding = 0
            Looper:
                iterable = modes
                Label:
                    text = f'{loop_item.capitalize()} note'
                Field:
                    text = experiment.mode_notes.get(loop_item, '')
                    text ::
                        experiment.mode_notes[loop_item] = text
        Looper:
            iterable = available_plugins
            CheckBox:
                checked = bool(loop_item.id in experiment.plugins)
                checked ::
                    if checked:
                        if loop_item.id not in experiment.plugins:
                            experiment.plugins.append(loop_item.id)
                    else:
                        experiment.plugins.remove(loop_item.id)
                text = loop_item.title


enamldef ExperimentSequence(Container): experiment_box:

    attr start_enabled = True
    attr save = True
    attr mode = 'classic'

    attr sequence
    attr edit_mode = False
    attr settings

    layout_constraints => ():
        # Align the subwidgets vertically
        widgets = self.visible_widgets()
        subwidgets = [w.visible_widgets() for w in widgets]
        return [
            vbox(*widgets),
            *[align('width', *c) for c in zip(*subwidgets)],
            *[align('left', *c) for c in zip(*subwidgets)],
        ]

    Looper: exp_loop:
        iterable << experiment_box.sequence

        Container:
            share_layout = True

            layout_constraints => ():
                widgets = self.visible_widgets()
                return [
                    hbox(*widgets),
                    align('v_center', *widgets),
                ]
            padding = 0

            Label:
                text = loop_item.label

            HGroup:
                padding = 0
                spacing = 0
                enabled << (experiment_box.start_enabled or edit_mode) and \
                    not settings.experiment_running

                Looper: mode_loop:
                    attr experiment = loop_item
                    iterable << loop_item.paradigm.info['modes']

                    PushButton:
                        text = loop_item.capitalize()
                        clicked ::
                            # If we are runing in edit mode, we want to
                            # just add this to the current queue.
                            # Otherwise, we actually launch the experiment.
                            try:
                                settings.run_experiment(mode_loop.experiment, loop_item,
                                                        save=experiment_box.save)
                            except Exception as e:
                                log.exception(e)
                                critical(experiment_box, 'Error starting experiment', str(e))
                            # Update the preferences in case new ones were created
                            preferences.items = [str(p) for p in \
                                                 mode_loop.experiment.paradigm.list_preferences()]

            #Conditional:
            #    condition = experiment_box.mode == 'queue'
            #    Label:
            #        text = f'{loop_item.mode} {loop_item.ear} ear'

            ObjectCombo: preferences:
                items = [str(p) for p in loop_item.paradigm.list_preferences()]
                selected := loop_item.preference
                to_string = lambda x: Path(x).stem

            PushButton:
                attr plugins = [p for p in loop_item.paradigm.plugins \
                                if not p.required and not p.info.get('hide', False)]
                constraints = [width == 30]
                text = '⚙'
                visible = bool(plugins)
                clicked ::
                    popup = PluginPopup(parent=self,
                                        experiment=loop_item,
                                        available_plugins=plugins,
                                        modes=loop_item.paradigm.info['modes'])
                    popup.show()

            PushButton:
                visible << edit_mode
                constraints = [width == 30]
                text = '-'
                clicked ::
                    seq = experiment_box.sequence[:]
                    seq.remove(loop_item)
                    experiment_box.sequence = seq

    Container:
        padding = 0
        layout_constraints => ():
            return [
                hbox(*self.visible_widgets()),
                align('v_center', *self.visible_widgets()),
            ]
        Label:
            pass
        Label:
            pass
        Label:
            pass
        Label:
            pass
        PushButton: pb_add_seq:
            visible << edit_mode
            constraints = [width == 30]
            text = '+'
            clicked ::
                print(paradigm_manager.list_paradigms('ear'))



enamldef AddRemoveCombo(Container):

    alias items: combo.items
    alias selected: combo.selected
    attr regex = '.*'

    padding = 0

    constraints = [hbox(combo, hbox(pb_add, pb_remove, spacing=0))]

    ObjectCombo: combo:
        pass

    PushButton: pb_add:
        text = '+'
        constraints = [width == 30]
        clicked ::
            popup = AddItem(parent=self, combo=combo, regex=regex)
            popup.show()

    PushButton: pb_remove:
        text = '-'
        constraints = [width == 30]
        enabled << bool(combo.items)
        clicked ::
            items = combo.items[:]
            items.remove(combo.selected)
            combo.items = items


enamldef ExperimentInfo(GroupBox):
    title = 'Experiment Info'

    constraints = [
        vbox(
            hbox(experimenter_label, experimenter_field),
            hbox(animal_label, animal_field, hbox(l_button, r_button, spacing=0)),
            hbox(note_label, note_field),
            hbox(standard_note_label, standard_note),
            hbox(spacer(0), pb_raw, pb_proc),
        ),
        align('right', experimenter_label, animal_label, note_label, standard_note_label),
        align('left', experimenter_label, animal_label, note_label, standard_note_label),
        align('v_center', experimenter_label, experimenter_field),
        align('v_center', animal_label, animal_field, l_button, r_button),
        align('v_center', note_label, note_field),
        align('v_center', standard_note_label, standard_note),
        align('v_center', pb_raw, pb_proc),
        l_button.width == 30,
        r_button.width == 30,
        pb_raw.width == 90,
        pb_proc.width == 90,
    ]

    ButtonGroup: ear_group:
        pass

    Label: experimenter_label:
        text = 'Experimenter'

    Field: experimenter_field:
        text := settings.experimenter

    Label: animal_label:
        text = 'Animal'

    Field: animal_field:
        text := settings.animal

    Label: note_label:
        text = 'Note'

    Field: note_field:
        text := settings.note

    Label: standard_note_label:
        text = 'Standard notes'

    AddRemoveCombo: standard_note:
        items << settings.standard_notes
        items ::
            settings.standard_notes = items[:]

    PushButton: l_button:
        text = 'L'
        checkable = True
        group = ear_group
        checked << settings.ear == 'left'
        checked ::
            settings.ear = 'left'

    PushButton: r_button:
        text = 'R'
        checkable = True
        group = ear_group
        checked << settings.ear == 'right'
        checked ::
            settings.ear = 'right'

    PushButton: pb_raw:
        text = '📂 Raw'
        clicked ::
            os.startfile(DATA_ROOT)

    PushButton: pb_proc:
        text = '📂 Processed'
        clicked ::
            os.startfile(PROC_ROOT)


enamldef Main(MainWindow): main:

    title = 'Cochlear Function Test Suite'

    attr settings = Settings()
    attr edit_mode = False

    MenuBar:
        Menu:
            title = '&File'
            Action:
                text = 'Load config\tCtrl+O'
                triggered ::
                    path = CFTS_ROOT / 'cfts-launcher'
                    path.mkdir(exist_ok=True)
                    filename = FileDialogEx.get_open_file_name(
                        current_path=str(path),
                        name_filters=['Experiment Settings (*.json)'],
                    )
                    settings.load_config(filename)
            Action:
                text = 'Save config\tCtrl+O'
                triggered ::
                    path = CFTS_ROOT / 'cfts-launcher'
                    path.mkdir(exist_ok=True)
                    filename = FileDialogEx.get_save_file_name(
                        current_path=str(path),
                        name_filters=['Experiment Settings (*.json)'],
                    )
                    settings.save_config(filename)
            Action:
                separator = True
            Action:
                text = 'Edit config'
                checkable = True
                checked := main.edit_mode

        Menu:
            title = '&Options'
            Menu:
                title = 'Logging Level'
                ActionGroup:
                    Looper:
                        iterable = settings.get_member('logging_level').items
                        Action:
                            checkable = True
                            text = loop_item
                            checked ::
                                settings.logging_level = loop_item
                            checked << settings.logging_level == loop_item
            Action:
                separator = True
            Action:
                text = '&Record calibration microphone'
                checkable = True
                checked := settings.record_cal_mic
            Action:
                text = '&Record output monitor signal'
                checkable = True
                checked := settings.record_output_monitor
            Action:
                text = '&Monitor body temperature'
                checkable = True
                checked := settings.record_body_temperature
            Action:
                text = '&Run in-ear calibration'
                checkable = True
                checked := settings.run_inear_calibration

    Container:

        constraints = [
            vbox(
                starship_info,
                experiment_info,
                experiment_nb,
                experiment_stats,
            ),
        ]

        GroupBox: starship_info:
            title = 'Equipment Configuration'
            flat = True
            share_layout = True

            layout_constraints => ():
                header = children[:3]
                widgets = [c for c in children[3:] \
                           if not isinstance(c, Looper) \
                           and not isinstance(c, Container)]
                extra_widgets = [c for c in children[3:] if isinstance(c, Container)]
                extra_labels = [w.children[0] for w in extra_widgets]
                zipped = list(zip(
                    widgets[0::4],   # labels
                    widgets[1::4],   # ear select
                    widgets[2::4],   # starship select
                    widgets[3::4],   # gain select
                ))
                constraints = [
                    vbox(
                        hbox(*header),
                        *[hbox(*r) for r in zipped],
                        *extra_widgets,
                    ),
                ]
                constraints.extend([align('v_center', *r) for r in zipped])
                constraints.extend([
                    align('left', header[0], *widgets[1::4]),
                    align('left', header[1], *widgets[2::4]),
                    align('left', header[2], *widgets[3::4]),
                    align('left', eeg_label, *widgets[0::4]),
                    align('left', eeg_input_name, header[0]),
                ])
                return constraints

            Label:
                text = 'Ear'
            Label:
                text = 'Calibration'
            Label:
                text = 'Gain'

            Looper:
                iterable << settings.starship_config.keys()
                Label:
                    text = f'Starship {loop_item}'
                ObjectCombo:
                    items = ['either', 'left', 'right', 'not used']
                    selected << settings.starship_config[loop_item]['ear']
                    selected ::
                        settings.starship_config[loop_item]['ear'] = selected
                ObjectCombo:
                    items << sorted(starship_manager.list_objects())
                    selected << settings.starship_config[loop_item]['calibration']
                    selected ::
                        settings.starship_config[loop_item]['calibration'] = selected
                ObjectCombo:
                    items = [20, 40]
                    selected << settings.starship_config[loop_item]['gain']
                    selected ::
                        settings.starship_config[loop_item]['gain'] = selected

            Label:
                text = 'Cal. mic.'
                visible << settings.record_cal_mic

            Label:
                text = ''
                visible << settings.record_cal_mic

            ObjectCombo: selected_mic:
                items = sorted(microphone_manager.list_objects())
                selected << settings.cal_mic_config['microphone']
                selected ::
                    settings.cal_mic_config['microphone'] = selected
                visible << settings.record_cal_mic

            ObjectCombo:
                items = [-20, -10, 0, 10, 20, 30, 40, 50]
                selected << settings.cal_mic_config['gain']
                selected ::
                    settings.cal_mic_config['gain'] = selected
                visible << settings.record_cal_mic

            Container:
                padding = 0
                share_layout = True

                constraints = [
                    hbox(*self.visible_widgets()),
                    align('v_center', *self.visible_widgets()),
                ]

                Label: eeg_label:
                    text ='EEG amplifier'

                ObjectCombo: eeg_input_name:
                    attr choices = list_input_amplifier_connections()
                    attr choices_lookup << {v: k for k, v in choices.items()}
                    items << list(choices_lookup)
                    selected << settings.input_amp_config['input_name']
                    selected ::
                        settings.input_amp_config['input_name'] = selected
                    to_string = choices_lookup.get

                ObjectCombo: eeg_gain:
                    items = [10e3, 20e3, 50e3, 100e3]
                    selected << settings.input_amp_config['gain']
                    selected ::
                        settings.input_amp_config['gain'] = selected
                    to_string = lambda x: f'{x:.0f} ✕'

                ObjectCombo: eeg_freq_lb:
                    items = [10, 300]
                    selected << settings.input_amp_config['freq_lb']
                    selected ::
                        settings.input_amp_config['freq_lb'] = selected
                    to_string = lambda x: f'{x} Hz'

                Label: eeg_to_label:
                    text = 'to'

                ObjectCombo: eeg_freq_ub:
                    items = [3000, 10000]
                    selected << settings.input_amp_config['freq_ub']
                    selected ::
                        settings.input_amp_config['freq_ub'] = selected
                    to_string = lambda x: f'{x} Hz'

        ExperimentInfo: experiment_info:
            pass

        Notebook: experiment_nb:
            tab_style = 'document'
            Page:
                title = 'Checks (not saved)'
                closable = False
                Container:
                    padding = 0
                    ExperimentSequence:
                        sequence << main.settings.monitor_sequence
                        save = False
                        edit_mode << main.edit_mode
                        settings << main.settings
            Page:
                title = 'Experiments'
                closable = False
                Container:
                    padding = 0
                    ExperimentSequence: experiment_box:
                        share_layout = True
                        start_enabled << (bool(main.settings.animal) and bool(main.settings.experimenter))
                        sequence << main.settings.experiment_sequence
                        edit_mode << main.edit_mode
                        settings << main.settings
            Page:
                title = 'Queues'
                closable = False
                Container:
                    padding = 0
                    HGroup:
                        align_widths = False
                        Label:
                            text = 'Name'
                        AddRemoveCombo:
                            items << list(settings.queues.keys())
                    ExperimentSequence:
                        mode = 'queue'
                        sequence << main.settings.current_queue
                        edit_mode << main.edit_mode
                        settings << main.settings

        GroupBox: experiment_stats:
            title = 'Experiment Info'
            flat = True
            share_layout = True

            Label:
                text << f'Last run took {settings.duration//60} min and {settings.duration % 60} sec'
